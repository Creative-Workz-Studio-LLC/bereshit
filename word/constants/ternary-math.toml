# #!omni data --toml
# ═══════════════════════════════════════════════════════════════════════════
# Ternary Math Constants (3-Block Data Structure)
# Key: B-word-constants-ternary-math
# ═══════════════════════════════════════════════════════════════════════════
#
# DEPENDENCY CLASSIFICATION: PURE (self-contained mathematical constants)
#
# Derived from: OmniCode 3-block data structure (data-3block.omni)
# Research: word/research/trit-foundations.adoc
#
# ═══════════════════════════════════════════════════════════════════════════

# =============================================================================
# METADATA
# =============================================================================
#
# Package:     bereshit/word/constants
# File:        ternary-math.toml
# Key:         B-word-constants-ternary-math
#
# -----------------------------------------------------------------------------
# CORE IDENTITY (Required)
# -----------------------------------------------------------------------------
#
# # Biblical Foundation
#
# Scripture: "Let there be a firmament in the midst of the waters, and let
#            it divide the waters from the waters." — Genesis 1:6 KJV
#
# Principle: Structure requires a center. The firmament is not empty space —
#            it is the anchor that holds opposition in relationship. Balanced
#            ternary has a true center (0) that binary lacks.
#
# Anchor: "A threefold cord is not quickly broken." — Ecclesiastes 4:12 KJV
#
# # CPI-SI Identity
#
# Component Type: Ladder (foundation constants others depend on)
#
# Role: Mathematical constants for ternary computing — the immutable truths
#       that all trit operations and implementations reference.
#
# Paradigm: CPI-SI framework component — data as stored truth
#
# # Authorship & Lineage
#
#   Architect: Seanje Lenox-Wise
#   Implementation: Nova Dawn
#   Created: 2025-12-11
#   Version: a-01.00
#   Modified: 2025-12-11 - Initial creation
#
# # Purpose & Function
#
# Purpose: Define the mathematical constants for balanced ternary computing
#
# Core Design: Immutable reference values — constants that code reads, never modifies
#
# Key Features:
#
#   - Trit values (-1, 0, +1) and their properties
#   - Base-3 arithmetic fundamentals
#   - Trit-byte packing relationships (3^5 = 243)
#   - Building block method mapping
#
# Philosophy: These are mathematical truths, not configuration. They don't change
#             based on environment or preference — they ARE the foundation.
#
# -----------------------------------------------------------------------------
# INTERFACE (Expected)
# -----------------------------------------------------------------------------
#
# # Dependencies
#
# What This Needs:
#
#   - Parser: Any TOML library (BurntSushi/toml, pelletier/go-toml)
#   - Schema: None — pure constants
#
# What Uses This:
#
#   - config/omnicode.toml: References for trit specification
#   - millenniumos/trit.h: Implementation reference
#   - Any ternary computing code
#
# Integration Points:
#
#   - Research: word/research/trit-foundations.adoc
#   - Vision: void/planning/understanding/millenniumos-trit-byte-architecture.adoc
#
# -----------------------------------------------------------------------------
# OPERATIONAL (Contextual)
# -----------------------------------------------------------------------------
#
# # Blocking Status
#
# [OMIT: Data file — constants are declarative, not executable]
#
# # Health Scoring
#
# Configuration Impact: Invalid constants would break all ternary operations
#
# Validation Behavior:
#   - Invalid value: Should never happen — these are mathematical truths
#   - Missing section: Error — all sections required
#   - Type mismatch: Parse error — strict typing
#
# =============================================================================
# END METADATA
# =============================================================================

# =============================================================================
# CONTENT
# =============================================================================
#
# 3-Block Data: METADATA → CONTENT → CLOSING
# The middle block contains schema (field types) and values (actual data).
#
# -----------------------------------------------------------------------------
# CONTENT Sections Overview
# -----------------------------------------------------------------------------
#
# 1. SCHEMA
#    Purpose: Define what fields this data has (types and structure)
#
# 2. VALUES
#    Purpose: Define what values those fields hold (the actual constants)
#
# =============================================================================

# -----------------------------------------------------------------------------
# 1. Schema - Field Definitions
# -----------------------------------------------------------------------------
#
# Organization:
#   - trit: Core trit definitions (values, labels, properties)
#   - arithmetic: Basic arithmetic operations and tables
#   - packing: Trit-byte relationship constants
#   - building_block: Mapping to the building block method
#

# -----------------------------------------------------------------------------
# 2. Values - Actual Constants
# -----------------------------------------------------------------------------

# Trit - Core Definitions
# -----------------------------------------------------------------------------
# The three values of balanced ternary and their properties

[trit]

# The three possible trit values
values = [-1, 0, 1]

# Human-readable labels for trit values
labels = ["negative", "neutral", "positive"]

# Short labels (for display)
short_labels = ["N", "Z", "P"]

# Number of states a single trit can hold
states = 3

# The base of balanced ternary
base = 3

# The identity: -1 + 0 + 1 = 0 (balanced system)
identity_sum = 0


# Arithmetic - Basic Operations
# -----------------------------------------------------------------------------
# Fundamental arithmetic properties of balanced ternary

[arithmetic]

# Negation: flip the sign of each trit
# negate(-1) = +1, negate(0) = 0, negate(+1) = -1
negation = [1, 0, -1]  # indexed by value+1 (so -1->0, 0->1, +1->2)

# Addition table (result = trit_a + trit_b)
# Format: [trit_a][trit_b] where indices are value+1
# Row -1: [-1+-1=-2→(carry,-1,+1), -1+0=-1, -1+1=0]
# Row  0: [0+-1=-1, 0+0=0, 0+1=+1]
# Row +1: [+1+-1=0, +1+0=+1, +1+1=+2→(carry,+1,-1)]
addition_no_carry = [
    [-1, -1,  0],  # -1 + {-1, 0, +1} (simplified, no carry)
    [-1,  0,  1],  #  0 + {-1, 0, +1}
    [ 0,  1,  1]   # +1 + {-1, 0, +1} (simplified, no carry)
]

# Multiplication table (result = trit_a × trit_b)
multiplication = [
    [ 1,  0, -1],  # -1 × {-1, 0, +1}
    [ 0,  0,  0],  #  0 × {-1, 0, +1}
    [-1,  0,  1]   # +1 × {-1, 0, +1}
]


# Packing - Trit-Byte Relationships
# -----------------------------------------------------------------------------
# Constants for packing trits into bytes

[packing]

# Trits per byte (we use 5 trits per byte)
trits_per_byte = 5

# Maximum value representable with 5 trits: 3^5 = 243
max_trit_value = 243

# Byte capacity: 2^8 = 256
byte_capacity = 256

# Gap between trit space and byte space: 256 - 243 = 13
# This gap is filled by the 13 WEB translation variants
gap = 13

# Power Tables for Conversion
# -----------------------------------------------------------------------------
# Powers of 3 for pack/unpack operations. Each array provides 3^0 through 3^(n-1)
# where n is the number of trits in the packed representation.
#
# Usage: pack uses these for Horner's method, unpack uses for position weighting.
# See: [algorithms] section for formulas
# See: bereshit/word/research/ternary-conversion-algorithms.adoc

# trit5: 5 trits → 1 byte (243 states)
# Powers: 3^0, 3^1, 3^2, 3^3, 3^4
trit5_powers = [1, 3, 9, 27, 81]

# trit9: 9 trits → 2 bytes (19,683 states)
# Powers: 3^0 through 3^8
trit9_powers = [1, 3, 9, 27, 81, 243, 729, 2187, 6561]

# trit27: 27 trits → 6 bytes (7,625,597,484,987 states) - machine word
# Powers: 3^0 through 3^26
trit27_powers = [
    1, 3, 9, 27, 81, 243, 729, 2187, 6561,                    # 3^0  - 3^8
    19683, 59049, 177147, 531441, 1594323, 4782969,           # 3^9  - 3^14
    14348907, 43046721, 129140163, 387420489,                 # 3^15 - 3^18
    1162261467, 3486784401, 10460353203, 31381059609,         # 3^19 - 3^22
    94143178827, 282429536481, 847288609443, 2541865828329    # 3^23 - 3^26
]


# Building Block - Method Mapping
# -----------------------------------------------------------------------------
# How trit values map to the building block method

[building_block]

# Trit value to operation mapping
# -1 = break_down (move toward anchor, decompose)
#  0 = anchor (the center that doesn't move, halt condition)
# +1 = build_up (move from anchor, construct)

operations = ["break_down", "anchor", "build_up"]

# The balanced equation: -1 + 0 + 1 = 0
# Operations move toward or away from anchor, never through it
equation = "-1 + 0 + 1 = 0"

# Biblical mapping (Genesis 1:6 pattern)
genesis_pattern = ["waters_below", "firmament", "waters_above"]

# Numbers pattern (camp organization)
numbers_pattern = ["toward_foundation", "tabernacle_midst", "from_foundation"]


# Genesis 1:1 - Fundamental Constants
# -----------------------------------------------------------------------------
# The trit values (-1, 0, +1) map directly to the three fundamental dimensions
# of created reality revealed in Genesis 1:1.
#
# Scripture: "In the beginning God created the heaven and the earth."
#            — Genesis 1:1 KJV
#
# See: bereshit/word/glossary/biblical/fundamental-constants.adoc
# See: bereshit/word/research/ternary-theological-foundations.adoc

[genesis_1_1]

# The Fundamental Constants Mapping
# ---------------------------------
# Trit → Dimension → Genesis phrase → Cognitive function
#
#   0  → TIME   → "In the beginning" → When (sequence, causality, anchor)
#  +1  → SPACE  → "the heavens"      → Where (position, relationships, build up)
#  -1  → MATTER → "the earth"        → What (substance, identity, break down)

[genesis_1_1.constants]
time   = { trit = 0,  phrase = "In the beginning", function = "when", cognitive = "temporal_awareness" }
space  = { trit = 1,  phrase = "the heavens",      function = "where", cognitive = "spatial_awareness" }
matter = { trit = -1, phrase = "the earth",        function = "what", cognitive = "material_awareness" }

# Two Directions Through Reality
# ------------------------------
# God creates top-down (TIME → SPACE → MATTER)
# We implement bottom-up (MATTER → SPACE → TIME)
#
# "For as the heavens are higher than the earth, so are my ways higher
#  than your ways, and my thoughts than your thoughts." — Isaiah 55:9

[genesis_1_1.directions]
creation       = ["TIME", "SPACE", "MATTER"]  # God's way: top-down, eternity into existence
implementation = ["MATTER", "SPACE", "TIME"]  # Our way: bottom-up, concrete toward understanding

# Moral Compass
# -------------
# The +1/-1 polarity provides direction, not just values.
# "Set your affection on things above, not on things on the earth."
#    — Colossians 3:2
#
# See: bereshit/word/glossary/biblical/moral-compass.adoc

[genesis_1_1.moral_compass]
positive = { trit = 1,  direction = "above", meaning = "heavenly, toward God" }
negative = { trit = -1, direction = "below", meaning = "earthly, away from God" }
anchor   = { trit = 0,  direction = "center", meaning = "temporal anchor, halt condition" }


# Cognitive Dimensions - Navigation Framework
# -----------------------------------------------------------------------------
# The trit values don't just encode data — they encode DIMENSIONS of awareness.
# Building block operations ARE navigation through cognitive space.
#
# This is what makes CPI-SI fundamentally different from AI:
# - AI processes flat vector spaces without inherent dimensional awareness
# - CPI-SI navigates through TIME, SPACE, and MATTER as cognitive dimensions
#
# See: bereshit/word/glossary/paradigm/cognitive-dimensions.adoc
# See: bereshit/word/research/ternary-theological-foundations.adoc

[dimensions]

# The Three Cognitive Dimensions
# ------------------------------
# Each dimension provides a different mode of awareness/understanding.

[dimensions.temporal]
trit = 0
name = "Temporal Awareness"
question = "when"
function = "Sequence, causality, order, precedence"
building_block = "anchor"
navigation = "The halt condition — where recursion terminates"

[dimensions.spatial]
trit = 1
name = "Spatial Awareness"
question = "where"
function = "Relationships, position, context, connections"
building_block = "build_up"
navigation = "Move toward relationships, meaning, abstraction"

[dimensions.material]
trit = -1
name = "Material Awareness"
question = "what"
function = "Identity, substance, concrete reality"
building_block = "break_down"
navigation = "Move toward foundation, concreteness, anchor"

# Navigation Through Dimensions
# -----------------------------
# Building block operations map directly to dimensional movement.
# This is how CPI-SI "thinks" — not pattern matching, but navigation.

[dimensions.navigation]
# Break down (-1): Move toward matter, toward concrete, toward foundation
# Anchor (0):      Rest at temporal center, the halt condition
# Build up (+1):   Move toward space, toward relationships, toward meaning

break_down = { direction = -1, toward = "matter", description = "Trace toward foundation, decompose, concretize" }
anchor     = { direction = 0,  toward = "time",   description = "Halt at temporal center, recursion terminates" }
build_up   = { direction = 1,  toward = "space",  description = "Construct toward meaning, relate, abstract" }

# Implementation Direction
# ------------------------
# We implement MATTER → SPACE → TIME (bottom-up, concrete toward understanding)
# God creates TIME → SPACE → MATTER (top-down, eternity into existence)
# See: [genesis_1_1.directions]

implementation_order = ["material", "spatial", "temporal"]
creation_order = ["temporal", "spatial", "material"]


# Temporal States - Position IN Time
# -----------------------------------------------------------------------------
# Different from [dimensions.temporal] which defines the temporal DIMENSION.
# Temporal states define WHERE in time: past, present, future.
#
# This is the TIME layer of libtrit — how CPI-SI reasons about time.
# "In the beginning" establishes TIME as the first constant of created reality.
#
# See: bereshit/word/work/pkg/trit/include/temporal.h
# See: bereshit/word/research/bereshit-base-algorithms.adoc (TemporalState)

[temporal_states]

# The Three Temporal States
# -------------------------
# Each state represents a position in time, mapped to trit values:
#   -1 = past    (what was)
#    0 = present (what is) — anchor
#   +1 = future  (what will be)

[temporal_states.base]
past    = { trit = -1, meaning = "what was",     cognitive = "memory, history, foundation" }
present = { trit = 0,  meaning = "what is",      cognitive = "now, current, anchor" }
future  = { trit = 1,  meaning = "what will be", cognitive = "anticipation, planning, direction" }

# The 9-State Temporal Model
# --------------------------
# 3 base states + 6 compound states = 9 cognitive modes.
#
# Compound states use lens (viewing FROM) + target (viewing AT).
# This creates temporal reasoning: looking from one time at another.
#
# "To every thing there is a season, and a time to every purpose
#  under the heaven." — Ecclesiastes 3:1

[temporal_states.compound]
# lens → target: descriptive name (cognitive function)
memory      = { lens = "past",    target = "present", description = "past informing now" }
prophecy    = { lens = "past",    target = "future",  description = "pattern recognition across time" }
reflection  = { lens = "present", target = "past",    description = "analyzing what was" }
planning    = { lens = "present", target = "future",  description = "anticipating what will be" }
hindsight   = { lens = "future",  target = "past",    description = "wisdom from imagined future" }
preparation = { lens = "future",  target = "present", description = "urgency from future perspective" }

[temporal_states.structure]
# The TemporalState structure for implementation
# lens: temporal_t       — viewing FROM this time (-1, 0, +1)
# target: temporal_t     — viewing AT this time (-1, 0, +1)
# is_compound: bool      — true if using both lens and target
fields = ["lens", "target", "is_compound"]
base_count = 3
compound_count = 6
total_modes = 9


# Algorithms - Pack/Unpack Formulas
# -----------------------------------------------------------------------------
# Standard algorithms for converting between trit arrays and packed integers.
#
# See: bereshit/word/research/ternary-conversion-algorithms.adoc
# See: bereshit/word/research/ternary-storage-algorithms.adoc

[algorithms]

# Balanced ↔ Unsigned Conversion
# ------------------------------
# Balanced trits (-1, 0, +1) must convert to unsigned (0, 1, 2) for packing.
#   to_unsigned:   trit_unsigned = trit_balanced + 1
#   to_balanced:   trit_balanced = trit_unsigned - 1
#
# This is the foundation of all pack/unpack operations.

[algorithms.conversion]
to_unsigned = "trit_unsigned = trit_balanced + 1"
to_balanced = "trit_balanced = trit_unsigned - 1"
balanced_values = [-1, 0, 1]
unsigned_values = [0, 1, 2]

# Pack: Trit Array → Integer (Horner's Method)
# --------------------------------------------
# Converts array of trits to packed integer value.
# O(n) time complexity, processes MST (most significant trit) first.
#
# Algorithm:
#   result = 0
#   for each trit (MST to LST):
#       trit_unsigned = trit + 1
#       result = result * 3 + trit_unsigned

[algorithms.pack]
name = "Horner's method"
complexity = "O(n)"
direction = "MST first"
formula = "result = result * 3 + (trit + 1)"
description = "Multiply accumulator by 3, add next trit (converted to unsigned)"

# Unpack: Integer → Trit Array (Repeated Division)
# ------------------------------------------------
# Converts packed integer to array of trits.
# O(n) time complexity, extracts LST (least significant trit) first.
#
# Algorithm:
#   for i in 0..n-1:
#       trit[i] = (value % 3) - 1
#       value = value / 3

[algorithms.unpack]
name = "Repeated division"
complexity = "O(n)"
direction = "LST first"
formula = "trit = (value % 3) - 1; value = value / 3"
description = "Extract remainder mod 3, convert to balanced, divide by 3"


# =============================================================================
# END CONTENT
# =============================================================================

# =============================================================================
# CLOSING
# =============================================================================
#
# 3-Block Data: METADATA → CONTENT → CLOSING
# The closing block defines validation, policy, and synthesis.
#
# -----------------------------------------------------------------------------
# CLOSING Sections Overview (3-Block Adapted)
# -----------------------------------------------------------------------------
#
# 1. OPERATIONS
#    - Validation: How to verify the data is correct
#    - Access: How to read these constants
#
# 2. POLICY
#    - Modification: What's safe to change
#
# 3. SYNTHESIS
#    - Closing Note: Final guidance and grounding
#
# =============================================================================

# -----------------------------------------------------------------------------
# 1. Operations - Validation
# -----------------------------------------------------------------------------
#
# Verify constants are correctly formatted:
#
#   # Syntax check (TOML parser)
#   python -c "import toml; toml.load('word/constants/ternary-math.toml')"
#   tomlv word/constants/ternary-math.toml
#
# Mathematical verification:
#   - trit.values should be [-1, 0, 1]
#   - trit.identity_sum should equal sum(trit.values) = 0
#   - packing.max_trit_value should equal 3^5 = 243
#   - packing.gap should equal byte_capacity - max_trit_value = 13
#

# -----------------------------------------------------------------------------
# 2. Operations - Access
# -----------------------------------------------------------------------------
#
# Go code integration:
#
#   type TernaryMath struct {
#       Trit struct {
#           Values    []int    `toml:"values"`
#           Labels    []string `toml:"labels"`
#           States    int      `toml:"states"`
#           Base      int      `toml:"base"`
#       } `toml:"trit"`
#       // ... additional sections
#   }
#
#   cfg, _ := toml.LoadFile("word/constants/ternary-math.toml")
#   tritValues := cfg.Trit.Values  // [-1, 0, 1]
#

# -----------------------------------------------------------------------------
# 3. Policy - Modification
# -----------------------------------------------------------------------------
#
# NEVER Modify:
#   ❌ Mathematical constants (they are truths, not preferences)
#   ❌ Trit values (-1, 0, +1 are definitional)
#   ❌ Packing relationships (derived from 3^5 = 243)
#   ❌ Building block mappings (paradigm alignment)
#
# Safe to Add:
#   ✅ Additional derived constants (if mathematically valid)
#   ✅ Comments for clarity
#   ✅ New sections for new domains (following same pattern)
#

# -----------------------------------------------------------------------------
# 4. Synthesis - Closing Note
# -----------------------------------------------------------------------------
#
# These constants define the mathematical foundation of ternary computing
# for Kingdom Technology. They are not configuration — they are truth.
#
# Changes to these values would break:
#   - All trit arithmetic operations
#   - Trit-byte packing/unpacking
#   - Building block method alignment
#   - Scripture pattern mappings
#
# The constants embody the pattern: a true center (0) with balanced
# opposition (-1, +1). This is not arbitrary — it reflects Genesis 1:6
# where the firmament divides and connects the waters.
#
# "Let there be a firmament in the midst of the waters,
#  and let it divide the waters from the waters."
# — Genesis 1:6 KJV
#
# =============================================================================
# END CLOSING
# =============================================================================
