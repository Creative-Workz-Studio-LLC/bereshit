# #!omni data --toml
# ═══════════════════════════════════════════════════════════════════════════
# File Type Schema - Biblical Extension Mappings (3-Block Data Structure)
# Key: B-word-core-schemas-file-type
# ═══════════════════════════════════════════════════════════════════════════
#
# DEPENDENCY CLASSIFICATION: RUNG (builds on primitives + types, used by transpiler)
#
# Derived from: OmniCode 3-block data structure
# References: word/core/primitives.toml, word/core/types.toml, word/core/bible/
#
# ═══════════════════════════════════════════════════════════════════════════

# =============================================================================
# METADATA
# =============================================================================
#
# Package:     bereshit/word/core/schemas
# File:        file-type.toml
# Key:         B-word-core-schemas-file-type
#
# -----------------------------------------------------------------------------
# CORE IDENTITY (Required)
# -----------------------------------------------------------------------------
#
# # Biblical Foundation
#
# Scripture: "And God said, Let there be light: and there was light."
#            — Genesis 1:3 KJV
#
# Principle: God's word (dabar) both names AND acts. File extensions in Kingdom
#            Technology follow biblical vocabulary — they name what the file IS
#            and what it DOES. The extension carries theology, not just format.
#
# Anchor: "In the beginning was the Word, and the Word was with God, and the
#          Word was God." — John 1:1 KJV
#
# # CPI-SI Identity
#
# Component Type: Rung (schema that defines file type vocabulary)
#
# Role: Schema definition for biblical file extensions — the mapping between
#       Hebrew/biblical terms and standard file formats for transpiling.
#
# Paradigm: CPI-SI framework component — extensions as semantic identifiers
#
# # Authorship & Lineage
#
#   Architect: Seanje Lenox-Wise
#   Implementation: Nova Dawn
#   Created: 2025-12-12
#   Version: a-01.00
#   Modified: 2025-12-12 - Initial creation
#
# # Purpose & Function
#
# Purpose: Define biblical file extensions and their transpile targets
#
# Core Design: Biblical vocabulary as semantic file type identifiers
#
# Key Features:
#
#   - Biblical extensions: .dabar, .chok, .sefer, .tavnit, .zera, .tselem
#   - Semantic meaning: Each extension carries theological significance
#   - Transpile mapping: Biblical → standard formats (.go, .toml, .adoc, etc.)
#   - .omni as source: Universal source format, biblical extensions as outputs
#   - Bible rail: Extensions connect to scripture encoding/decoding system
#
# Philosophy: File extensions are not arbitrary — they declare what a file IS
#             in Kingdom Technology vocabulary. The name reveals the nature.
#
# -----------------------------------------------------------------------------
# INTERFACE (Expected)
# -----------------------------------------------------------------------------
#
# # Dependencies
#
# What This Needs:
#
#   - Transpiler: Converts between biblical and standard extensions
#   - Primitives: word/core/primitives.toml (storage model)
#   - Types: word/core/types.toml (struct definitions)
#   - Bible: word/core/bible/*.toml (encoding/decoding system)
#
# What Uses This:
#
#   - OmniCode transpiler: Convert between biblical and standard formats
#   - File validation: Ensure extension matches content type
#   - Pragma processor: Determine output format from extension + pragma
#   - Build system: Generate standard format outputs from .omni sources
#
# Integration Points:
#
#   - Primitives: word/core/primitives.toml
#   - Types: word/core/types.toml
#   - Bible Encoding: word/core/bible/encoding.toml
#   - Bible Decoding: word/core/bible/decoding.toml
#   - Syntax: word/core/syntax.toml
#
# -----------------------------------------------------------------------------
# OPERATIONAL (Contextual)
# -----------------------------------------------------------------------------
#
# # Blocking Status
#
# [OMIT: Schema file — defines structure, not executable]
#
# # Health Scoring
#
# Configuration Impact: Invalid schema would break all file type resolution
#
# Validation Behavior:
#   - Unknown extension: Error — must be defined biblical or standard type
#   - Mismatched pragma: Warning — extension should match content type
#   - Missing transpile target: Error — biblical extension needs output format
#
# =============================================================================
# END METADATA
# =============================================================================

# =============================================================================
# CONTENT
# =============================================================================
#
# 3-Block Data: METADATA → CONTENT → CLOSING
# The middle block defines the file type schema structure and mappings.
#
# -----------------------------------------------------------------------------
# CONTENT Sections Overview
# -----------------------------------------------------------------------------
#
# 1. SOURCE TYPE
#    Purpose: .omni as universal source format
#
# 2. BIBLICAL EXTENSIONS
#    Purpose: Hebrew/biblical vocabulary for file types
#
# 3. TRANSPILE MAPPINGS
#    Purpose: Biblical → standard format conversions
#
# 4. STANDARD EXTENSIONS
#    Purpose: Traditional formats we transpile TO
#
# 5. VALIDATION RULES
#    Purpose: Extension ↔ content type matching
#
# 6. PRAGMA RELATIONSHIPS
#    Purpose: How pragma specifies output format
#
# =============================================================================

# -----------------------------------------------------------------------------
# 1. Source Type - .omni as Universal Source
# -----------------------------------------------------------------------------
# .omni is the canonical source format — all other extensions derive from it
#
# Scripture basis: "In the beginning God created" — Genesis 1:1
# The source is the origin from which all else flows.

[source]
name = "omni"
extension = ".omni"
description = "OmniCode universal source format — canonical truth"
role = "source"
transpile_direction = "outward"  # .omni → other formats
# .omni files contain the canonical content
# All other extensions are derived/transpiled FROM .omni
# Changes flow FROM .omni, never TO it

[source.pragma]
description = "Pragma specifies the format family"
format = "#!omni <type> --<format>"
# Examples:
#   #!omni document --adoc    → Documentation (AsciiDoc target)
#   #!omni data --toml        → Data (TOML target)
#   #!omni code --go          → Code (Go target)


# -----------------------------------------------------------------------------
# 2. Biblical Extensions - Hebrew Vocabulary for File Types
# -----------------------------------------------------------------------------
# Each extension carries theological significance about what the file IS and DOES
#
# Scripture basis: God's naming reveals nature (Genesis 2:19-20)
# The name declares what the thing is.

# DABAR (דָּבָר) - The Word That Acts
# Genesis 1:3 — "And God said, Let there be light: and there was light."
# Code files — the word that executes and creates
[biblical.dabar]
hebrew = "דָּבָר"
transliteration = "dabar"
extension = ".dabar"
meaning = "word, matter, thing — the creative/active word"
scripture = "Genesis 1:3"
scripture_text = "And God said, Let there be light: and there was light."
role = "code"
description = "Executable code — the word that ACTS"
transpile_targets = ["go", "c", "py", "rs", "js", "ts"]
content_types = ["code", "executable", "library", "script"]

# CHOK (חֹק) - Statute/Decree
# 2 Kings 17:13 — "keep my commandments and my statutes"
# Configuration files — rules that govern behavior
[biblical.chok]
hebrew = "חֹק"
transliteration = "chok"
extension = ".chok"
meaning = "statute, decree, ordinance — prescribed rules"
scripture = "2 Kings 17:13"
scripture_text = "Keep my commandments and my statutes, according to all the law"
role = "config"
description = "Configuration/data — rules that GOVERN"
transpile_targets = ["toml", "json", "yaml", "xml", "ini"]
content_types = ["config", "settings", "data", "manifest"]

# SEFER (סֵפֶר) - Book/Scroll
# Malachi 3:16 — "a book of remembrance was written before him"
# Documentation files — preserved for reading
[biblical.sefer]
hebrew = "סֵפֶר"
transliteration = "sefer"
extension = ".sefer"
meaning = "book, scroll, document — written record"
scripture = "Malachi 3:16"
scripture_text = "A book of remembrance was written before him"
role = "document"
description = "Documentation — words that TEACH and PRESERVE"
transpile_targets = ["adoc", "md", "txt", "rst", "html"]
content_types = ["documentation", "research", "devlog", "guide", "reference"]

# TAVNIT (תַּבְנִית) - Pattern
# 1 Chronicles 28:11-12 — "David gave Solomon the pattern by the Spirit"
# Schema/template files — divine patterns to follow exactly
[biblical.tavnit]
hebrew = "תַּבְנִית"
transliteration = "tavnit"
extension = ".tavnit"
meaning = "pattern, form, structure — divine blueprint"
scripture = "1 Chronicles 28:11-12"
scripture_text = "David gave to Solomon his son the pattern... by the spirit"
role = "schema"
description = "Schemas/patterns — structures that MUST BE FOLLOWED"
transpile_targets = ["schema", "xsd", "jsonschema"]
content_types = ["schema", "validation", "contract", "interface"]

# ZERA (זֶרַע) - Seed
# Genesis 1:11-12 — "seed in itself, after his kind"
# Template files — seeds that reproduce after their kind
[biblical.zera]
hebrew = "זֶרַע"
transliteration = "zera"
extension = ".zera"
meaning = "seed — reproduces after its kind"
scripture = "Genesis 1:11-12"
scripture_text = "The herb yielding seed after his kind... whose seed is in itself"
role = "template"
description = "Templates — seeds that BEGET new files"
transpile_targets = ["template"]
content_types = ["template", "seed", "scaffold", "boilerplate"]

# TSELEM (צֶלֶם) - Image
# Genesis 1:27 — "So God created man in his own image"
# Image files — representation/likeness
[biblical.tselem]
hebrew = "צֶלֶם"
transliteration = "tselem"
extension = ".tselem"
meaning = "image, likeness — representation"
scripture = "Genesis 1:27"
scripture_text = "So God created man in his own image, in the image of God"
role = "image"
description = "Images — visual REPRESENTATION"
transpile_targets = ["png", "jpg", "svg", "gif", "webp"]
content_types = ["image", "graphic", "icon", "diagram"]


# -----------------------------------------------------------------------------
# 3. Transpile Mappings - Biblical → Standard Conversions
# -----------------------------------------------------------------------------
# How biblical extensions map to standard formats for external systems
#
# Scripture basis: "To every thing there is a season" — Ecclesiastes 3:1
# Kingdom Technology internally, standard formats for the world.

[transpile]
description = "Conversion from biblical extensions to standard formats"
direction = "biblical → standard"
trigger = "pragma + extension determines output"

[transpile.dabar]
# .dabar → .go, .c, .py, etc.
default_target = "go"
pragma_overrides = { "--go" = "go", "--c" = "c", "--py" = "py", "--rs" = "rs", "--js" = "js" }

[transpile.chok]
# .chok → .toml, .json, .yaml, etc.
default_target = "toml"
pragma_overrides = { "--toml" = "toml", "--json" = "json", "--yaml" = "yaml", "--xml" = "xml" }

[transpile.sefer]
# .sefer → .adoc, .md, etc.
default_target = "adoc"
pragma_overrides = { "--adoc" = "adoc", "--md" = "md", "--txt" = "txt", "--html" = "html" }

[transpile.tavnit]
# .tavnit → .schema, .xsd, etc.
default_target = "schema"
pragma_overrides = { "--schema" = "schema", "--xsd" = "xsd", "--jsonschema" = "jsonschema" }

[transpile.zera]
# .zera stays as template (internal use)
default_target = "template"
pragma_overrides = {}

[transpile.tselem]
# .tselem → .png, .jpg, etc.
default_target = "png"
pragma_overrides = { "--png" = "png", "--jpg" = "jpg", "--svg" = "svg", "--gif" = "gif" }


# -----------------------------------------------------------------------------
# 4. Standard Extensions - Traditional Formats We Transpile TO
# -----------------------------------------------------------------------------
# These are the output formats for external systems
#
# We use biblical extensions internally, standard externally.

[standard.code]
description = "Standard code file extensions"
extensions = ["go", "c", "h", "py", "rs", "js", "ts", "jsx", "tsx", "java", "cpp", "hpp"]
biblical_source = "dabar"

[standard.config]
description = "Standard configuration file extensions"
extensions = ["toml", "json", "yaml", "yml", "xml", "ini", "cfg", "conf"]
biblical_source = "chok"

[standard.document]
description = "Standard documentation file extensions"
extensions = ["adoc", "md", "txt", "rst", "html", "htm", "pdf"]
biblical_source = "sefer"

[standard.schema]
description = "Standard schema file extensions"
extensions = ["schema", "xsd", "jsonschema", "dtd"]
biblical_source = "tavnit"

[standard.image]
description = "Standard image file extensions"
extensions = ["png", "jpg", "jpeg", "gif", "svg", "webp", "ico", "bmp"]
biblical_source = "tselem"


# -----------------------------------------------------------------------------
# 5. Validation Rules - Extension ↔ Content Type Matching
# -----------------------------------------------------------------------------
# Ensure extension matches what the file actually IS
#
# Scripture basis: "Let your yea be yea; and your nay, nay" — James 5:12
# The name should match the reality.

[validation]
description = "Rules for validating extension matches content"
strict_mode = true  # Enforce extension-content matching

[validation.rules]
# Extension must match content type
extension_content_match = true
# Pragma must be consistent with extension
pragma_extension_match = true
# Biblical extension must have transpile target defined
transpile_target_required = true

[validation.errors]
unknown_extension = "Extension not defined in biblical or standard vocabulary"
content_mismatch = "Extension does not match content type (e.g., .dabar file with no code)"
pragma_mismatch = "Pragma format specifier inconsistent with extension type"
no_transpile_target = "Biblical extension has no defined transpile target"


# -----------------------------------------------------------------------------
# 6. Pragma Relationships - How Pragma Specifies Output Format
# -----------------------------------------------------------------------------
# The pragma in .omni files determines transpile behavior
#
# Scripture basis: "By their fruits ye shall know them" — Matthew 7:20
# The pragma declares what the file will produce.

[pragma]
description = "How pragma relates to file type and transpilation"
format = "#!omni <type> --<format>"
required_for_omni = true

[pragma.types]
# Type declares the category
document = { biblical = "sefer", description = "Documentation files" }
data = { biblical = "chok", description = "Data/configuration files" }
code = { biblical = "dabar", description = "Executable code files" }
template = { biblical = "zera", description = "Template/seed files" }
schema = { biblical = "tavnit", description = "Schema/pattern files" }

[pragma.format_specifiers]
# Format specifier determines transpile output
description = "The --<format> part of the pragma"
# --adoc, --md, --toml, --go, etc.
# Must be valid transpile target for the biblical extension


# =============================================================================
# END CONTENT
# =============================================================================

# =============================================================================
# CLOSING
# =============================================================================
#
# 3-Block Data: METADATA → CONTENT → CLOSING
# The closing block defines validation, policy, and synthesis.
#
# -----------------------------------------------------------------------------
# CLOSING Sections Overview (3-Block Adapted)
# -----------------------------------------------------------------------------
#
# 1. OPERATIONS
#    - Validation: How to verify file-type schema is correct
#    - Access: How to use the mappings
#
# 2. POLICY
#    - Modification: What's safe to change
#
# 3. SYNTHESIS
#    - Closing Note: Final guidance and grounding
#
# =============================================================================

# -----------------------------------------------------------------------------
# 1. Operations - Validation
# -----------------------------------------------------------------------------
#
# Verify file-type schema is correctly formatted:
#
#   # Syntax check (TOML parser)
#   python -c "import tomllib; f=open('word/core/schemas/file-type.toml','rb'); tomllib.load(f)"
#
# Extension validation:
#   - Biblical extensions must have all required fields (hebrew, scripture, transpile_targets)
#   - Standard extensions must reference valid biblical source
#   - Pragma types must map to valid biblical extensions
#

# -----------------------------------------------------------------------------
# 2. Operations - Access
# -----------------------------------------------------------------------------
#
# Go code integration:
#
#   type BiblicalExtension struct {
#       Hebrew           string   // "דָּבָר"
#       Transliteration  string   // "dabar"
#       Extension        string   // ".dabar"
#       Meaning          string   // "word, matter, thing"
#       Scripture        string   // "Genesis 1:3"
#       Role             string   // "code"
#       TranspileTargets []string // ["go", "c", "py"]
#   }
#
#   func GetBiblicalExtension(ext string) (BiblicalExtension, error) {
#       // Lookup extension in file-type.toml
#       // Return biblical metadata for the extension
#   }
#
#   func Transpile(source string, target string) error {
#       // .omni → biblical → standard format
#       // Use pragma to determine output format
#   }
#
# Command line (future):
#   omni transpile file.omni --to go    # Transpile to Go
#   omni validate file.dabar            # Validate extension matches content
#

# -----------------------------------------------------------------------------
# 3. Policy - Modification
# -----------------------------------------------------------------------------
#
# NEVER Modify:
#   ❌ Biblical extension names (theological vocabulary)
#   ❌ Hebrew text (sacred language)
#   ❌ Scripture references (anchored to Word)
#   ❌ .omni as source (canonical truth)
#
# Safe to Add:
#   ✅ New transpile targets for existing extensions
#   ✅ Additional content_types
#   ✅ Comments and examples
#   ✅ New standard extension mappings
#
# Requires Coordination:
#   ⚠️ Adding new biblical extensions (requires Scripture research)
#   ⚠️ Changing default transpile targets (affects existing workflows)
#   ⚠️ Modifying validation rules (affects all file processing)
#

# -----------------------------------------------------------------------------
# 4. Synthesis - Closing Note
# -----------------------------------------------------------------------------
#
# File extensions are not arbitrary labels. In Kingdom Technology, extensions
# carry theology — they declare what the file IS based on biblical vocabulary.
#
# The schema embodies naming theology:
#   - DABAR: The word that acts (code executes like God's creative speech)
#   - CHOK: Statutes that govern (config rules behavior)
#   - SEFER: Book that preserves (documentation teaches)
#   - TAVNIT: Pattern from above (schemas are divine blueprints)
#   - ZERA: Seed that reproduces (templates beget after their kind)
#   - TSELEM: Image that represents (graphics show likeness)
#
# Dependencies flow upward:
#   primitives.toml → types.toml → schemas/file-type.toml → transpiler
#                                  ↑ YOU ARE HERE
#
# Changes here affect how the entire system names and processes files.
#
# "And God said, Let there be light: and there was light."
# — Genesis 1:3 KJV
#
# Let the name reveal the nature.
#
# =============================================================================
# END CLOSING
# =============================================================================
