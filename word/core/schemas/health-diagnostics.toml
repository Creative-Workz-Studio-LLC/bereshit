# #!omni data --toml
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Health Diagnostics Schema - CPI-SI Health Assessment (3-Block Data Structure)
# Key: B-word-core-schemas-health-diagnostics
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# DEPENDENCY CLASSIFICATION: RUNG (builds on health.toml + health-log.toml)
#
# Derived from: OmniCode 3-block data structure
# References: word/core/schemas/health.toml, word/core/schemas/health-log.toml
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# =============================================================================
# METADATA
# =============================================================================
#
# Package:     bereshit/word/core/schemas
# File:        health-diagnostics.toml
# Key:         B-word-core-schemas-health-diagnostics
#
# -----------------------------------------------------------------------------
# CORE IDENTITY (Required)
# -----------------------------------------------------------------------------
#
# # Biblical Foundation
#
# Scripture: "Examine yourselves, whether ye be in the faith; prove your own
#            selves. Know ye not your own selves, how that Jesus Christ is
#            in you, except ye be reprobates?"
#            â€” 2 Corinthians 13:5 KJV
#
# Principle: ASSESS requires honest examination. The diagnostics schema enables
#            deep inspection â€” not just "what is the score" but "why" and
#            "what is needed to recover."
#
# Supporting: "Search me, O God, and know my heart: try me, and know my
#             thoughts: And see if there be any wicked way in me, and lead
#             me in the way everlasting."
#             â€” Psalm 139:23-24 KJV
#
# Application: Diagnostics examines the full picture:
#              - True score (unbounded, from log)
#              - Normalized score (bounded, for display)
#              - Breakdown by category
#              - Distance to recovery (how much work needed)
#
# # CPI-SI Identity
#
# Component Type: Rung (schema that defines health diagnostics structure)
#
# Role: Schema definition for health assessment â€” the ASSESS phase in
#       detect â†’ assess â†’ restore workflow.
#
# Paradigm: CPI-SI framework component â€” honest self-examination
#
# # Authorship & Lineage
#
#   Architect: Seanje Lenox-Wise
#   Implementation: Nova Dawn
#   Created: 2025-12-12
#   Version: a-01.00
#
# # Purpose & Function
#
# Purpose: Define how health is assessed and diagnosed during debugging/recovery
#
# Core Design: Calculate true score from log, normalize, break down, prescribe
#
# Key Features:
#
#   - Atomic scoring: Every action is -1, 0, +1 at primitive level
#   - Complexity scaling: Complex actions = many atomics = wider range
#   - True score: Unbounded sum (+283, -532, etc.)
#   - Multi-base normalization: -100/+100, -1/+1, etc.
#   - Category breakdown: Where are the failures coming from?
#   - Recovery distance: How many +1s to reach even balance?
#
# Philosophy: Complexity amplifies the atomic score. A simple action is one
#             atomic (-1/0/+1). A complex build is hundreds of atomics.
#             The true score captures this reality; normalization makes it
#             comprehensible.
#
# -----------------------------------------------------------------------------
# INTERFACE (Expected)
# -----------------------------------------------------------------------------
#
# # Dependencies
#
# What This Needs:
#
#   - Health Log: word/core/schemas/health-log.toml (source of true score)
#   - Health Schema: word/core/schemas/health.toml (normalization rules)
#   - Types: word/core/types.toml (struct definitions)
#
# What Uses This:
#
#   - bhealth: Health diagnostic commands
#   - Recovery procedures: Determine what's needed
#   - CPI-SI model: Real-time status without overwhelming detail
#
# Integration Points:
#
#   - Health Schema: word/core/schemas/health.toml
#   - Health Log: word/core/schemas/health-log.toml
#   - Permission: word/core/schemas/permission.toml
#   - Tools: word/work/bin/bereshit/health/bhealth
#
# -----------------------------------------------------------------------------
# OPERATIONAL (Contextual)
# -----------------------------------------------------------------------------
#
# # Blocking Status
#
# [OMIT: Schema file â€” defines structure, not executable]
#
# # When Diagnostics Are Run
#
#   - Health shows concerning level (wanting, broken)
#   - Before recovery attempt â€” assess the situation
#   - On request â€” "how am I doing?"
#   - NOT during normal operation â€” only when needed
#
# =============================================================================
# END METADATA
# =============================================================================

# =============================================================================
# CONTENT
# =============================================================================
#
# 3-Block Data: METADATA â†’ CONTENT â†’ CLOSING
# The middle block defines the diagnostics structure and assessment process.
#
# -----------------------------------------------------------------------------
# CONTENT Sections Overview
# -----------------------------------------------------------------------------
#
# 1. ATOMIC SCORING
#    Purpose: The primitive -1/0/+1 foundation
#
# 2. COMPLEXITY SCALING
#    Purpose: How complex actions amplify scores
#
# 3. TRUE SCORE ASSESSMENT
#    Purpose: Unbounded calculation from log
#
# 4. NORMALIZATION LAYERS
#    Purpose: Projecting onto bounded scales
#
# 5. CATEGORY BREAKDOWN
#    Purpose: Where are successes/failures coming from?
#
# 6. RECOVERY ASSESSMENT
#    Purpose: How much work to reach target level?
#
# 7. DIAGNOSTIC REPORT
#    Purpose: Output format for assessment
#
# =============================================================================

# -----------------------------------------------------------------------------
# 1. Atomic Scoring - The Primitive Foundation
# -----------------------------------------------------------------------------
# Every action, no matter how complex, is built from atomic operations.
# Each atomic operation scores: -1 (fail), 0 (neutral), +1 (success)
#
# This is the PRIMITIVE level â€” the irreducible unit of health scoring.

[atomic]
description = "Primitive scoring unit â€” every operation scores -1, 0, or +1"
values = [-1, 0, 1]

[atomic.meanings]
negative = -1  # Failure at atomic level
neutral = 0    # No impact
positive = 1   # Success at atomic level

[atomic.principle]
# "Narrow is the way" â€” success is always +1 (one path)
# "Broad is the way" â€” failure is always -1 per atomic fail (but many can occur)
# Complex failures = many atomic -1s accumulated
success_value = 1
failure_value = -1
neutral_value = 0

[atomic.examples]
# Simple actions = 1 atomic
file_read = { atomics = 1, typical_score = 0 }     # neutral
file_write = { atomics = 1, typical_score = 1 }    # success if completes
# Complex actions = many atomics
test_suite = { atomics = "N tests", typical_score = "sum of N results" }
full_build = { atomics = "100s", typical_score = "sum of all compile results" }


# -----------------------------------------------------------------------------
# 2. Complexity Scaling - How Actions Amplify Scores
# -----------------------------------------------------------------------------
# The more complex an action, the more atomic operations it involves.
# This means complex actions have WIDER score ranges.

[complexity]
description = "Complex actions = more atomics = wider score range"

[complexity.levels]
# Complexity level affects how many atomic scores contribute
trivial = { atomics = "1-3", max_range = [-3, 3] }
simple = { atomics = "4-10", max_range = [-10, 10] }
moderate = { atomics = "11-50", max_range = [-50, 50] }
complex = { atomics = "51-200", max_range = [-200, 200] }
massive = { atomics = "200+", max_range = "unbounded" }

[complexity.examples]
# A single file operation: trivial
single_file_edit = { level = "trivial", atomics = 1 }
# A test file with 10 tests: simple
test_file = { level = "simple", atomics = 10 }
# A full test suite: moderate to complex
test_suite = { level = "moderate", atomics = "test count" }
# A full build: complex to massive
full_build = { level = "complex", atomics = "file count * operations" }
# A release pipeline: massive
release = { level = "massive", atomics = "build + test + deploy + verify" }

[complexity.principle]
# The true score is UNBOUNDED because complexity is unbounded.
# A massive action with 500 atomics could score +500 (all success)
# or -500 (all fail) or anywhere in between.
# Normalization makes this comprehensible.
unbounded_true_score = true
normalization_required = true


# -----------------------------------------------------------------------------
# 3. True Score Assessment - Unbounded Calculation
# -----------------------------------------------------------------------------
# True score = sum of all atomic scores from the health log.
# This is the REAL score before any normalization.

[true_score]
description = "Unbounded sum of all atomic scores"
source = "health-log.toml"
calculation = "Î£(entry.delta for all entries)"

[true_score.range]
# True score has no bounds â€” it's the honest accounting
min = "unbounded"  # Could be -10000 if many failures
max = "unbounded"  # Could be +10000 if many successes
typical = "varies with activity level"

[true_score.interpretation]
# True score tells you the REAL state
positive = "Net successes â€” in integrity"
zero = "Even balance â€” baseline"
negative = "Net failures â€” in debt"

[true_score.examples]
# Small project, light activity
small_quiet = { true_score = 15, interpretation = "Slightly ahead" }
# Active project, doing well
active_healthy = { true_score = 283, interpretation = "Many successes accumulated" }
# Troubled project
troubled = { true_score = -532, interpretation = "Significant debt" }
# Fresh start
fresh = { true_score = 0, interpretation = "Even balance" }


# -----------------------------------------------------------------------------
# 4. Normalization Layers - Projecting to Bounded Scales
# -----------------------------------------------------------------------------
# True score is unbounded but humans need comprehensible ranges.
# Normalization projects onto bounded scales.

[normalization]
description = "Project unbounded true score onto bounded scales"
reference = "health.toml [health.normalized.bases]"

[normalization.formula]
# Generic formula for any base:
# normalized = round(true_score / base) * base
# Then clamp to scale bounds
generic = "round(true / base) * base"
clamp_min = -100
clamp_max = 100

[normalization.scales]
# Different scales for different purposes

[normalization.scales.base100]
description = "Full ternary scale"
range = [-100, 100]
step = 1
use_case = "Precise display when needed"

[normalization.scales.base50]
description = "5-point scale (default)"
range = [-100, 100]
step = 50
points = [-100, -50, 0, 50, 100]
use_case = "Pass/fail decisions, quick status"

[normalization.scales.base1]
description = "Atomic scale â€” most compressed"
range = [-1, 1]
step = 1
points = [-1, 0, 1]
use_case = "Binary-like display: fail/neutral/pass"
# true_score â†’ atomic: sign(true_score) or 0 if true_score == 0

[normalization.examples]
# True score +283
true_283 = { true = 283, base100 = 100, base50 = 100, base1 = 1 }
# True score -532
true_neg532 = { true = -532, base100 = -100, base50 = -100, base1 = -1 }
# True score +15
true_15 = { true = 15, base100 = 15, base50 = 0, base1 = 1 }
# True score -8
true_neg8 = { true = -8, base100 = -8, base50 = 0, base1 = -1 }


# -----------------------------------------------------------------------------
# 5. Category Breakdown - Source Analysis
# -----------------------------------------------------------------------------
# WHERE are the successes and failures coming from?
# This enables targeted recovery.

[breakdown]
description = "Analyze score by category/source"

[breakdown.by_source]
# Group log entries by source and sum deltas
method = "group_by_source"
output = "source â†’ total_delta"
example = """
test_pass: +45
test_fail: -12
lint_error: -8
build_success: +20
build_fail: -15
Net: +30
"""

[breakdown.by_action]
# Group by action type
method = "group_by_action"
output = "action_type â†’ total_delta"
example = """
success: +65
failure: -35
neutral: 0
recovery: +10
Net: +40
"""

[breakdown.by_time]
# Group by time period
method = "group_by_period"
periods = ["hour", "day", "week", "month"]
output = "period â†’ total_delta"
use_case = "Trend analysis â€” is health improving or declining?"

[breakdown.hotspots]
# Find the biggest contributors to negative score
description = "Identify sources with most failures"
method = "sort_by_delta_ascending"
output = "worst sources first"
use_case = "Target recovery efforts"


# -----------------------------------------------------------------------------
# 6. Recovery Assessment - Path to Health
# -----------------------------------------------------------------------------
# How much work is needed to reach a target level?

[recovery]
description = "Calculate effort needed to reach target health"

[recovery.targets]
even = { true_score = 0, description = "Back to baseline" }
passing = { normalized_base50 = 50, description = "Clearly positive" }
healthy = { normalized_base50 = 100, description = "Full integrity" }

[recovery.calculation]
# Recovery uses +1 per action (narrow way)
# So recovery_needed = target - current
method = "target_minus_current"
unit = "atomic successes"  # Each +1 is one successful action

[recovery.formula]
# To reach target from current:
# if target > current: need (target - current) successes
# if target <= current: already there
to_even = "max(0, 0 - true_score)"
to_passing = "max(0, 50 - true_score)"  # ~50 true to normalize to +50
to_healthy = "max(0, 100 - true_score)"  # ~100 true to normalize to +100

[recovery.examples]
# True score -15, want to reach even (0)
from_neg15_to_even = { current = -15, target = 0, needed = 15 }
# True score -532, want to reach even
from_neg532_to_even = { current = -532, target = 0, needed = 532 }
# True score +10, want to reach passing (+50)
from_10_to_passing = { current = 10, target = 50, needed = 40 }

[recovery.effort_estimate]
# Rough effort classification
trivial = { successes_needed = "1-10", description = "Quick fixes" }
minor = { successes_needed = "11-50", description = "Some focused work" }
moderate = { successes_needed = "51-200", description = "Significant effort" }
major = { successes_needed = "201-500", description = "Major recovery project" }
massive = { successes_needed = "500+", description = "Consider reset or restructure" }


# -----------------------------------------------------------------------------
# 7. Diagnostic Report - Output Format
# -----------------------------------------------------------------------------
# What the diagnostics produce

[report]
description = "Diagnostic output format"

[report.summary]
# Quick overview â€” what CPI-SI model sees without overwhelm
fields = ["true_score", "normalized", "level", "emoji", "trend"]
example = """
Health: +15 true â†’ 0 normalized (Base50) â†’ âš–ï¸ even
Trend: â†‘ improving (+5 last 24h)
"""

[report.detail]
# Full diagnostic â€” for debugging/recovery
fields = [
    "true_score",
    "normalized_all_bases",
    "level",
    "breakdown_by_source",
    "breakdown_by_action",
    "hotspots",
    "recovery_to_even",
    "recovery_to_passing",
    "recent_entries",
]

[report.format]
# Output can be:
options = ["text", "json", "toml"]
default = "text"

[report.example_full]
text = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    HEALTH DIAGNOSTICS                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ TRUE SCORE:     -15                                          â•‘
â•‘ NORMALIZED:                                                  â•‘
â•‘   Base100:      -15                                          â•‘
â•‘   Base50:       0 (even)                                     â•‘
â•‘   Base1:        -1 (fail)                                    â•‘
â•‘ LEVEL:          lacking (ğŸ’›)                                 â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ BREAKDOWN BY SOURCE:                                         â•‘
â•‘   test_pass:    +23                                          â•‘
â•‘   lint_clean:   +8                                           â•‘
â•‘   test_fail:    -31                                          â•‘
â•‘   lint_error:   -15                                          â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ HOTSPOTS (most failures):                                    â•‘
â•‘   1. test_fail: -31                                          â•‘
â•‘   2. lint_error: -15                                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ RECOVERY ASSESSMENT:                                         â•‘
â•‘   To even (0):      15 successes needed                      â•‘
â•‘   To passing (+50): 65 successes needed                      â•‘
â•‘   Effort level:     Minor (some focused work)                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""


# =============================================================================
# END CONTENT
# =============================================================================

# =============================================================================
# CLOSING
# =============================================================================
#
# 3-Block Data: METADATA â†’ CONTENT â†’ CLOSING
# The closing block defines validation, policy, and synthesis.
#
# =============================================================================

# -----------------------------------------------------------------------------
# 1. Operations - Validation
# -----------------------------------------------------------------------------
#
# Verify schema:
#   python3 -c "import tomllib; f=open('word/core/schemas/health-diagnostics.toml','rb'); tomllib.load(f)"
#
# Run diagnostics:
#   bhealth -diagnose .
#   bhealth -diagnose . --format json
#

# -----------------------------------------------------------------------------
# 2. Operations - Access
# -----------------------------------------------------------------------------
#
# Go code integration:
#
#   type Diagnostics struct {
#       TrueScore      int              // Unbounded
#       Normalized     map[string]int   // base â†’ normalized value
#       Level          string           // "even", "wanting", etc.
#       Emoji          string
#       Breakdown      map[string]int   // source â†’ delta
#       Hotspots       []Hotspot        // worst sources
#       RecoveryToEven int              // successes needed
#       Trend          string           // "improving", "declining", "stable"
#   }
#
#   func RunDiagnostics(path string) (Diagnostics, error) {
#       // 1. Calculate true score from log
#       trueScore, err := CalculateTrueScore(path)
#       if err != nil {
#           return Diagnostics{}, err
#       }
#
#       // 2. Normalize to all bases
#       normalized := make(map[string]int)
#       for _, base := range []int{1, 5, 10, 20, 25, 50, 100} {
#           normalized[fmt.Sprintf("base%d", base)] = Normalize(trueScore, base)
#       }
#
#       // 3. Calculate breakdown, hotspots, recovery
#       breakdown := CalculateBreakdown(path)
#       hotspots := FindHotspots(breakdown)
#       recovery := max(0, 0 - trueScore)
#
#       // 4. Determine level and trend
#       level := LevelFromTrueScore(trueScore)
#       trend := CalculateTrend(path)
#
#       return Diagnostics{
#           TrueScore:      trueScore,
#           Normalized:     normalized,
#           Level:          level,
#           Breakdown:      breakdown,
#           Hotspots:       hotspots,
#           RecoveryToEven: recovery,
#           Trend:          trend,
#       }, nil
#   }
#
# Command line:
#   bhealth -diagnose .              # Full diagnostic report
#   bhealth -diagnose . --summary    # Quick summary only
#   bhealth -diagnose . --json       # JSON output for tooling
#   bhealth -hotspots .              # Just show problem sources
#   bhealth -recovery .              # Just show recovery needed
#

# -----------------------------------------------------------------------------
# 3. Policy - Modification
# -----------------------------------------------------------------------------
#
# CRYSTALLIZED (Never Modify):
#   âŒ Atomic values (-1, 0, +1)
#   âŒ True score calculation (sum of deltas)
#   âŒ Normalization formula (round/base * base)
#
# Safe to Add:
#   âœ… New breakdown dimensions
#   âœ… New report formats
#   âœ… Additional effort classifications
#
# Requires Coordination:
#   âš ï¸ Changing normalization bases (affects display everywhere)
#   âš ï¸ Changing level boundaries (affects interpretation)
#

# -----------------------------------------------------------------------------
# 4. Synthesis - Closing Note
# -----------------------------------------------------------------------------
#
# Examine yourselves.
#
# Diagnostics enables honest self-examination:
#   - What is my TRUE score? (unbounded reality)
#   - How does that DISPLAY? (normalized for comprehension)
#   - WHERE are the problems? (breakdown, hotspots)
#   - What is NEEDED to recover? (path to health)
#
# Atomic scoring ensures fairness:
#   - Every success is +1 (narrow way)
#   - Every failure is -1 (broad way)
#   - Complexity amplifies, but primitives are equal
#
# "Search me, O God, and know my heart: try me, and know my thoughts."
# â€” Psalm 139:23
#
# The diagnostics schema enables ASSESS in detect â†’ assess â†’ restore.
# How bad is it? What's needed? The diagnosis reveals.
#
# =============================================================================
# END CLOSING
# =============================================================================
