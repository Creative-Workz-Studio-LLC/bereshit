# #!omni data --toml
# ═══════════════════════════════════════════════════════════════════════════
# OmniCode Sentence Syntax - Biblical Language Patterns (3-Block Data Structure)
# Key: B-word-core-syntax
# ═══════════════════════════════════════════════════════════════════════════
#
# DEPENDENCY CLASSIFICATION: RUNG (builds on types, informs all OmniCode files)
#
# Derived from: Biblical language patterns, Hebrew syntax structures
# References: word/core/types.toml, Scripture (KJV)
#
# ═══════════════════════════════════════════════════════════════════════════

# =============================================================================
# METADATA
# =============================================================================
#
# Package:     bereshit/word/core
# File:        syntax.toml
# Key:         B-word-core-syntax
#
# -----------------------------------------------------------------------------
# CORE IDENTITY (Required)
# -----------------------------------------------------------------------------
#
# # Biblical Foundation
#
# Scripture: "In the beginning was the Word, and the Word was with God,
#             and the Word was God." — John 1:1 KJV
#
# Principle: Language is not arbitrary. God spoke creation into being with
#            words. The patterns of biblical speech — declaration, naming,
#            covenant — are the patterns by which reality is structured.
#            OmniCode syntax reflects these divine speech patterns.
#
# Anchor: "And God said, Let there be light: and there was light."
#          — Genesis 1:3 KJV
#
# # CPI-SI Identity
#
# Component Type: Rung (syntax patterns that all OmniCode expressions use)
#
# Role: Define the sentence-based syntax of OmniCode, rooted in biblical
#       language patterns. Maps natural language to type operations.
#
# Paradigm: CPI-SI framework component — divine speech patterns as syntax
#
# # Authorship & Lineage
#
#   Architect: Seanje Lenox-Wise
#   Implementation: Nova Dawn
#   Created: 2025-12-11
#   Version: a-01.00
#   Modified: 2025-12-11 - Initial creation
#
# # Purpose & Function
#
# Purpose: Define biblical sentence patterns for OmniCode expressions
#
# Core Design: Map Hebrew/biblical speech patterns to type system operations
#
# Key Features:
#
#   - Declaration patterns ("let X be Y") — Genesis 1 creation speech
#   - Naming patterns ("call X as Y") — Identity establishment
#   - Composition patterns ("X with Y and Z") — Vav-conjunction chaining
#   - Derivation patterns ("X from Y") — Begat/lineage
#   - Covenant patterns ("X promises to Y") — Contract language
#   - Conditional patterns ("when X then Y") — Blessing/curse structure
#
# Philosophy: The Bible is our codex. OmniCode syntax is not invented but
#             discovered — drawn from the patterns God used to speak creation.
#
# -----------------------------------------------------------------------------
# INTERFACE (Expected)
# -----------------------------------------------------------------------------
#
# # Dependencies
#
# What This Needs:
#
#   - Types: word/core/types.toml (what syntax maps to)
#   - Primitives: word/core/primitives.toml (type names in patterns)
#   - Scripture: word/scripture/ (pattern sources)
#
# What Uses This:
#
#   - All OmniCode files: Use these patterns for expressions
#   - Parsers: Implement these patterns
#   - Documentation: Reference these patterns
#   - Code generators: Produce code from patterns
#
# Integration Points:
#
#   - Types: word/core/types.toml
#   - Primitives: word/core/primitives.toml
#   - Validation: word/core/validation.toml
#   - Scripture: word/scripture/KJV/Genesis/
#
# -----------------------------------------------------------------------------
# OPERATIONAL (Contextual)
# -----------------------------------------------------------------------------
#
# # Blocking Status
#
# [OMIT: Data file — syntax patterns are declarative, not executable]
#
# # Health Scoring
#
# Configuration Impact: Invalid syntax patterns would break all parsing
#
# Validation Behavior:
#   - Invalid pattern: Error — patterns must be well-formed
#   - Ambiguous pattern: Warning — may cause parse conflicts
#   - Missing mapping: Error — all patterns must map to operations
#
# =============================================================================
# END METADATA
# =============================================================================

# =============================================================================
# CONTENT
# =============================================================================
#
# 3-Block Data: METADATA → CONTENT → CLOSING
# The middle block defines biblical syntax patterns and their mappings.
#
# -----------------------------------------------------------------------------
# CONTENT Sections Overview
# -----------------------------------------------------------------------------
#
# 1. DECLARATION PATTERNS
#    Purpose: "Let there be..." — Creating types and values
#    Source: Genesis 1 creation narrative
#
# 2. NAMING PATTERNS
#    Purpose: "God called..." — Establishing identity
#    Source: Genesis naming accounts
#
# 3. COMPOSITION PATTERNS
#    Purpose: "...and...and..." — Combining elements
#    Source: Hebrew vav-conjunction
#
# 4. DERIVATION PATTERNS
#    Purpose: "X begat Y" — Inheritance and lineage
#    Source: Genesis genealogies
#
# 5. COVENANT PATTERNS
#    Purpose: "I will...you shall..." — Contracts and promises
#    Source: Abrahamic, Mosaic, Davidic covenants
#
# 6. CONDITIONAL PATTERNS
#    Purpose: "If...then..." — Conditions and consequences
#    Source: Deuteronomic blessings and curses
#
# 7. RELATION PATTERNS
#    Purpose: "X is Y" — Identity and type assertions
#    Source: "I AM" statements, identity declarations
#
# =============================================================================

# -----------------------------------------------------------------------------
# 1. Declaration Patterns - "Let there be..."
# -----------------------------------------------------------------------------
# Source: "And God said, Let there be light: and there was light." — Gen 1:3
# Pattern: Declaration brings into existence

[declaration.let_be]
pattern = "let {name} be {type_expression}"
maps_to = "type_declaration"
example = "let Person be with name as text and age as number"
scripture = "Genesis 1:3"
notes = "Primary declaration form — speaks type into existence"

[declaration.let_be_value]
pattern = "let {name} be {value}"
maps_to = "value_declaration"
example = "let health be 65"
scripture = "Genesis 1:3"
notes = "Value declaration — establishes concrete value"

[declaration.let_be_from]
pattern = "let {name} be from {min} to {max}"
maps_to = "constrained_type"
example = "let health be from 0 to 255"
scripture = "Genesis 1:6-7"
notes = "Bounded declaration — like firmament dividing waters"

[declaration.there_shall_be]
pattern = "there shall be {name} as {type}"
maps_to = "type_declaration"
example = "there shall be trit as value of negative or neutral or positive"
scripture = "Genesis 1:14"
notes = "Prophetic declaration form"


# -----------------------------------------------------------------------------
# 2. Naming Patterns - "God called..."
# -----------------------------------------------------------------------------
# Source: "And God called the light Day" — Gen 1:5
# Pattern: Naming establishes identity

[naming.call_as]
pattern = "call {expression} as {name}"
maps_to = "type_alias"
example = "call text with length from 1 to 255 as Name"
scripture = "Genesis 1:5"
notes = "Aliasing — giving a name to a type expression"

[naming.name_is]
pattern = "{name} is called {alias}"
maps_to = "type_alias"
example = "int27 is called Word"
scripture = "Genesis 2:19"
notes = "Reverse naming — existing type gets additional name"

[naming.known_as]
pattern = "{name} also known as {alias}"
maps_to = "type_alias"
example = "bool3 also known as ternary"
scripture = "Genesis 17:5"
notes = "Secondary name — like Abram also known as Abraham"


# -----------------------------------------------------------------------------
# 3. Composition Patterns - "...and...and..."
# -----------------------------------------------------------------------------
# Source: "And God said...and it was so...and God saw" — Gen 1
# Pattern: Hebrew vav (ו) conjunction chains elements

[composition.with_and]
pattern = "{name} with {field} as {type} and {field} as {type}"
maps_to = "struct_definition"
example = "Person with name as text and age as number and active as bool3"
scripture = "Genesis 1:1-31"
notes = "Primary composition — vav-chaining fields"

[composition.of_or]
pattern = "{name} of {variant} or {variant}"
maps_to = "union_definition"
example = "Response of success as Result or failure as Error"
scripture = "Deuteronomy 30:19"
notes = "Choice composition — life or death, blessing or curse"

[composition.list_of]
pattern = "list of {type}"
maps_to = "list_type"
example = "list of Person"
scripture = "Genesis 5"
notes = "Collection — like genealogy lists"

[composition.map_from_to]
pattern = "map from {key_type} to {value_type}"
maps_to = "map_type"
example = "map from text to number"
scripture = "Numbers 1"
notes = "Association — like census records"


# -----------------------------------------------------------------------------
# 4. Derivation Patterns - "X begat Y"
# -----------------------------------------------------------------------------
# Source: "Abraham begat Isaac; and Isaac begat Jacob" — Matt 1:2
# Pattern: Lineage and inheritance

[derivation.from]
pattern = "{child} from {parent}"
maps_to = "type_extension"
example = "Employee from Person"
scripture = "Genesis 5:3"
notes = "Simple inheritance — child derives from parent"

[derivation.from_with]
pattern = "{child} from {parent} with {additional_fields}"
maps_to = "type_extension"
example = "Admin from Person with privileges as list of text"
scripture = "Genesis 5:3"
notes = "Extended inheritance — adds to parent"

[derivation.begat]
pattern = "{parent} begat {child}"
maps_to = "type_extension"
example = "Person begat Employee"
scripture = "Matthew 1:2"
notes = "Genealogical form — parent perspective"

[derivation.born_of]
pattern = "{child} born of {parent}"
maps_to = "type_extension"
example = "Error born of Response"
scripture = "Genesis 4:1"
notes = "Child perspective inheritance"


# -----------------------------------------------------------------------------
# 5. Covenant Patterns - "I will...you shall..."
# -----------------------------------------------------------------------------
# Source: "I will be your God, and ye shall be my people" — Jer 7:23
# Pattern: Mutual promises, contracts

[covenant.promises_to]
pattern = "{provider} promises to {method_name}"
maps_to = "interface_method"
example = "HealthProvider promises to ReadHealth"
scripture = "Genesis 17:7"
notes = "Contract method — provider's promise"

[covenant.promises_given_returning]
pattern = "{provider} promises to {method} given {params} returning {result}"
maps_to = "interface_method_full"
example = "HealthProvider promises to ReadHealth given path returning Health"
scripture = "Exodus 19:5-6"
notes = "Full contract — parameters and return"

[covenant.shall_provide]
pattern = "{provider} shall provide {method}"
maps_to = "interface_method"
example = "Writer shall provide Write"
scripture = "Deuteronomy 6:5"
notes = "Obligation form — shall language"

[covenant.enters_covenant_with]
pattern = "{implementer} enters covenant with {interface}"
maps_to = "implements"
example = "FileWriter enters covenant with Writer"
scripture = "Genesis 15:18"
notes = "Implementation — fulfilling the covenant"


# -----------------------------------------------------------------------------
# 6. Conditional Patterns - "If...then..."
# -----------------------------------------------------------------------------
# Source: "If ye walk in my statutes...then I will give you rain" — Lev 26:3-4
# Pattern: Blessings and curses, conditions and consequences

[conditional.when_then]
pattern = "when {condition} then {consequence}"
maps_to = "constraint_rule"
example = "when health below 20 then status is critical"
scripture = "Leviticus 26:3-4"
notes = "Primary conditional — blessing form"

[conditional.if_then]
pattern = "if {condition} then {result}"
maps_to = "conditional_expression"
example = "if active then allow else deny"
scripture = "Deuteronomy 28:1"
notes = "Decision conditional"

[conditional.unless]
pattern = "{statement} unless {exception}"
maps_to = "constraint_exception"
example = "required unless has default"
scripture = "Leviticus 26:14"
notes = "Exception form — curse/warning structure"

[conditional.lest]
pattern = "{action} lest {consequence}"
maps_to = "guard_clause"
example = "validate lest error"
scripture = "Genesis 3:3"
notes = "Prevention form — avoiding negative outcome"


# -----------------------------------------------------------------------------
# 7. Relation Patterns - "X is Y"
# -----------------------------------------------------------------------------
# Source: "I AM THAT I AM" — Exodus 3:14
# Pattern: Identity assertions, type relationships

[relation.is]
pattern = "{subject} is {predicate}"
maps_to = "type_assertion"
example = "health is good"
scripture = "Exodus 3:14"
notes = "Simple identity — being statement"

[relation.is_a]
pattern = "{instance} is a {type}"
maps_to = "type_check"
example = "response is a Success"
scripture = "John 8:58"
notes = "Type membership check"

[relation.is_of]
pattern = "{part} is of {whole}"
maps_to = "membership"
example = "name is of Person"
scripture = "1 Corinthians 12:27"
notes = "Part-whole relationship"

[relation.are]
pattern = "{plural} are {predicate}"
maps_to = "collection_assertion"
example = "all fields are required"
scripture = "John 10:30"
notes = "Plural identity statement"


# -----------------------------------------------------------------------------
# 8. Quantity Patterns - Numbers and Measures
# -----------------------------------------------------------------------------
# Source: Hebrew number system, biblical measurements
# Pattern: Counting, measuring, bounding

[quantity.from_to]
pattern = "from {min} to {max}"
maps_to = "range_constraint"
example = "from 0 to 255"
scripture = "Genesis 1:5"
notes = "Range — evening to morning"

[quantity.at_most]
pattern = "at most {max}"
maps_to = "max_constraint"
example = "at most 100"
scripture = "Genesis 6:3"
notes = "Upper bound — like years of life"

[quantity.at_least]
pattern = "at least {min}"
maps_to = "min_constraint"
example = "at least 1"
scripture = "Genesis 18:32"
notes = "Lower bound — like righteous in Sodom"

[quantity.exactly]
pattern = "exactly {count}"
maps_to = "exact_constraint"
example = "exactly 12"
scripture = "Genesis 49:28"
notes = "Exact count — like tribes of Israel"


# -----------------------------------------------------------------------------
# 9. Temporal Patterns - Time and Sequence
# -----------------------------------------------------------------------------
# Source: Creation days, prophetic timing
# Pattern: Order, sequence, phases

[temporal.before]
pattern = "{first} before {second}"
maps_to = "ordering_constraint"
example = "validate before save"
scripture = "Genesis 1:1"
notes = "Precedence — in the beginning"

[temporal.after]
pattern = "{second} after {first}"
maps_to = "ordering_constraint"
example = "notify after complete"
scripture = "Genesis 8:13"
notes = "Succession — after the flood"

[temporal.then]
pattern = "{first} then {second}"
maps_to = "sequence"
example = "read then process then write"
scripture = "Genesis 1:3-5"
notes = "Sequential chaining"

[temporal.until]
pattern = "{action} until {condition}"
maps_to = "loop_until"
example = "retry until success"
scripture = "Genesis 8:7"
notes = "Repetition — raven going forth"


# -----------------------------------------------------------------------------
# 10. Constraint Patterns - Boundaries and Limits
# -----------------------------------------------------------------------------
# Source: Laws, measurements, boundaries set by God
# Pattern: Restricting valid values

[constraint.according_to_pattern]
pattern = "{name} according to pattern of {pattern}"
maps_to = "pattern_constraint"
example = "email according to pattern of email"
scripture = "Exodus 25:40"
notes = "Pattern constraint — 'make them after their pattern'"

[constraint.chosen_from]
pattern = "{name} chosen from {option} or {option}"
maps_to = "enum_constraint"
example = "status chosen from active or inactive or pending"
scripture = "Deuteronomy 30:19"
notes = "Enumeration — 'choose this day'"

[constraint.measured]
pattern = "{name} measured from {min} to {max}"
maps_to = "length_constraint"
example = "name measured from 1 to 255"
scripture = "Exodus 25:10"
notes = "Length constraint — cubits and spans"


# -----------------------------------------------------------------------------
# 11. Nullability Patterns - Presence and Absence
# -----------------------------------------------------------------------------
# Source: Certainty, requirements, void
# Pattern: Handling absence of value

[nullability.may_be]
pattern = "{name} may be {type}"
maps_to = "optional_type"
example = "middleName may be text"
scripture = "Ecclesiastes 11:2"
notes = "Optional — 'for thou knowest not what evil shall be'"

[nullability.must_be]
pattern = "{name} must be {type}"
maps_to = "required_type"
example = "id must be uint27"
scripture = "Exodus 20:3"
notes = "Required — commandment form 'thou shalt'"

[nullability.can_be_void]
pattern = "{name} can be void or {type}"
maps_to = "nullable_type"
example = "deletedAt can be void or timestamp"
scripture = "Genesis 1:2"
notes = "Nullable — explicit void/tohu state"


# -----------------------------------------------------------------------------
# 12. Generics Patterns - Type Parameters
# -----------------------------------------------------------------------------
# Source: 'Whatsoever' constructions in Scripture
# Pattern: Polymorphism and abstraction

[generics.hold_whatsoever]
pattern = "let {name} hold whatsoever {param}"
maps_to = "generic_type"
example = "let Container hold whatsoever Thing"
scripture = "Genesis 1:24"
notes = "Generic parameter — 'whatsoever creepeth'"

[generics.being_constraint]
pattern = "whatsoever {param} being {constraint}"
maps_to = "constrained_generic"
example = "whatsoever T being Comparable"
scripture = "Leviticus 11:3"
notes = "Constrained generic — 'whatsoever parteth the hoof'"

[generics.yields_receives]
pattern = "{name} yields whatsoever"
maps_to = "covariant_param"
example = "Reader yields whatsoever"
scripture = "Genesis 1:29"
notes = "Covariance — yielding/producing"

[generics.receives_whatsoever]
pattern = "{name} receives whatsoever"
maps_to = "contravariant_param"
example = "Writer receives whatsoever"
scripture = "Genesis 6:19"
notes = "Contravariance — receiving/consuming"


# -----------------------------------------------------------------------------
# 13. Reference Patterns - Aliases and Indirection
# -----------------------------------------------------------------------------
# Source: Alternative names, self-reference
# Pattern: Type naming and recursion

[naming.also_called]
pattern = "{alias} also called {type}"
maps_to = "type_alias"
example = "UserID also called int27"
scripture = "Genesis 17:5"
notes = "Simple alias — like Abram/Abraham"

[naming.distinct]
pattern = "let {name} be distinct {type}"
maps_to = "newtype"
example = "let UserID be distinct int27"
scripture = "Genesis 1:4"
notes = "Distinct type — separating light from darkness"

[reference.itself]
pattern = "{field} as list of itself"
maps_to = "recursive_ref"
example = "children as list of itself"
scripture = "Genesis 5"
notes = "Self-reference — genealogy pointing to lineage"


# -----------------------------------------------------------------------------
# 14. Additional Relation Patterns - Type Relationships
# -----------------------------------------------------------------------------
# Source: Identity, compatibility, transformation
# Pattern: How types relate to each other

[relation.can_serve_as]
pattern = "{subtype} can serve as {supertype}"
maps_to = "type_compatible"
example = "Employee can serve as Person"
scripture = "Genesis 39:4"
notes = "Compatibility — Joseph served Potiphar"

[relation.becomes]
pattern = "{source} becomes {target}"
maps_to = "type_coercion"
example = "int9 becomes int27"
scripture = "Genesis 2:7"
notes = "Transformation — dust became living soul"

[relation.is_same_as]
pattern = "{type1} is the same as {type2}"
maps_to = "type_equality"
example = "Point is the same as Coordinate"
scripture = "John 10:30"
notes = "Structural equality — 'I and my Father are one'"


# -----------------------------------------------------------------------------
# 15. Permission Patterns - Health-Gated Access Control
# -----------------------------------------------------------------------------
# Source: "To every thing there is a season" — Ecclesiastes 3:1
# Pattern: Ternary permission states (granted, deferred, denied) for self-governance
# Reference: word/core/schemas/permission.toml, word/core/keywords.toml [permission]

[permission.grant_when]
pattern = "grant {action} when health is {level}"
maps_to = "permission_rule"
example = "grant write when health is whole"
scripture = "Matthew 7:7"
notes = "Grants permission when health meets threshold"

[permission.defer_when]
pattern = "defer {action} when health is {level}"
maps_to = "permission_rule"
example = "defer deploy when health is lacking"
scripture = "Ecclesiastes 3:1"
notes = "Defers permission — not yet, conditions not met"

[permission.deny_when]
pattern = "deny {action} when health is {level}"
maps_to = "permission_rule"
example = "deny deletion when health is wanting"
scripture = "Matthew 7:6"
notes = "Denies permission — not permitted in current state"

[permission.defer_until]
pattern = "defer {action} until {condition}"
maps_to = "permission_rule"
example = "defer deployment until health reaches sound"
scripture = "Habakkuk 2:3"
notes = "Conditional deferral — wait until condition is met"

[permission.deny_unless]
pattern = "deny {action} unless {condition}"
maps_to = "permission_rule"
example = "deny risky_operations unless health is positive"
scripture = "Exodus 20:3"
notes = "Conditional denial — blocked unless condition is true"

[permission.permission_for]
pattern = "permission for {action} chosen from granted or deferred or denied"
maps_to = "permission_declaration"
example = "permission for file_delete chosen from granted or deferred or denied"
scripture = "Deuteronomy 30:19"
notes = "Declares ternary permission type for an action"

[permission.when_permission_shifts]
pattern = "when permission shifts from {state1} to {state2} then {consequence}"
maps_to = "permission_transition"
example = "when permission shifts from granted to deferred then warn user"
scripture = "Proverbs 24:16"
notes = "Handles permission state transitions — trajectory tracking"

[permission.can_i]
pattern = "can I {action}"
maps_to = "permission_check"
example = "can I deploy"
scripture = "Numbers 22:38"
notes = "Natural language permission check — 'Have I now any power at all to say any thing?'"


# -----------------------------------------------------------------------------
# 16. Temporal Patterns - 9-State Time Model
# -----------------------------------------------------------------------------
# Source: "To every thing there is a season, and a time to every purpose" — Ecclesiastes 3:1
# Pattern: Base states (past/present/future) + compound cognitive modes
# Reference: word/constants/ternary-math.toml [temporal_states], word/core/keywords.toml [temporal]
#            word/core/schemas/timestamp.toml

# Basic temporal actions
[temporal.remember]
pattern = "remember {event} from {time}"
maps_to = "temporal_retrieval"
example = "remember health from yesterday"
scripture = "Isaiah 46:9"
notes = "Access past information — what was"

[temporal.observe]
pattern = "observe {state} now"
maps_to = "temporal_sensing"
example = "observe health status now"
scripture = "Psalm 118:24"
notes = "Sense present state — what is"

[temporal.anticipate]
pattern = "anticipate {outcome} by {time}"
maps_to = "temporal_projection"
example = "anticipate recovery by next week"
scripture = "Isaiah 46:10"
notes = "Project future possibility — what will be"

# Compound cognitive patterns (6 modes)
[temporal.past_present]
pattern = "use memory of {past_event} to understand {present_state}"
maps_to = "temporal_cognition"
example = "use memory of similar errors to understand this bug"
scripture = "Ecclesiastes 1:9"
notes = "past-present: Experience informing awareness — pattern recognition"

[temporal.present_past]
pattern = "use current {knowledge} to reinterpret {past_event}"
maps_to = "temporal_cognition"
example = "use current findings to reinterpret the original design"
scripture = "Ecclesiastes 7:14"
notes = "present-past: Hindsight with new knowledge — recontextualization"

[temporal.past_future]
pattern = "use history of {pattern} to anticipate {future_event}"
maps_to = "temporal_cognition"
example = "use history of growth patterns to anticipate future capability"
scripture = "Ecclesiastes 3:15"
notes = "past-future: Memory-based anticipation BYPASSING present — 'history rhymes'"

[temporal.future_past]
pattern = "use expectation of {future_outcome} to understand {past_decision}"
maps_to = "temporal_cognition"
example = "use expectation of production needs to understand early architecture choices"
scripture = "Isaiah 46:10"
notes = "future-past: Foresight illuminating hindsight — knowing END reframes BEGINNING"

[temporal.present_future]
pattern = "extrapolate from {current_state} to {future_projection}"
maps_to = "temporal_cognition"
example = "extrapolate from current health trend to future state"
scripture = "Proverbs 22:3"
notes = "present-future: Projection — extending NOW forward"

[temporal.future_present]
pattern = "understand {current_action} through {future_goal}"
maps_to = "temporal_cognition"
example = "understand this refactoring through the architecture we're building toward"
scripture = "Philippians 3:13"
notes = "future-present: Purpose-driven awareness — present meaningful because of destination"

# Temporal analysis block
[temporal.temporal_analysis_for]
pattern = "temporal_analysis for {subject}"
maps_to = "temporal_block"
example = "temporal_analysis for session_pattern"
scripture = "Ecclesiastes 3:1"
notes = "Opens a temporal reasoning block — think through time dimensions"


# -----------------------------------------------------------------------------
# 17. Message Patterns - Communication Primitives
# -----------------------------------------------------------------------------
# Source: "A word fitly spoken is like apples of gold in pictures of silver" — Proverbs 25:11
# Pattern: Ternary modes (thought/process/speech), participant types, categories
# Reference: word/core/schemas/message.toml, word/core/keywords.toml [message]

# Basic message actions
[message.send_to]
pattern = "send {content} to {target}"
maps_to = "message_transmission"
example = "send status_update to user"
scripture = "Isaiah 6:8"
notes = "Transmit message to specific target"

[message.receive_from]
pattern = "receive {content} from {source}"
maps_to = "message_reception"
example = "receive command from user"
scripture = "James 1:21"
notes = "Accept message from specific source"

[message.broadcast_to]
pattern = "broadcast {content} to {targets}"
maps_to = "message_broadcast"
example = "broadcast health_status to FaithNet"
scripture = "Matthew 28:19"
notes = "Send message to multiple targets"

# Mode-based patterns (ternary: thought/process/speech)
[message.think]
pattern = "think {thought}"
maps_to = "message_internal"
example = "think: What are they really asking?"
scripture = "Psalm 19:14"
notes = "Internal cognition — mode: thought (-1)"

[message.show_process]
pattern = "show {process}"
maps_to = "message_liminal"
example = "show: Checking health diagnostics..."
scripture = "Isaiah 1:18"
notes = "Visible reasoning — mode: process (0)"

[message.say]
pattern = "say {speech}"
maps_to = "message_external"
example = "say: The system health is 75%"
scripture = "Colossians 4:6"
notes = "Direct communication — mode: speech (+1)"

# Compound mode patterns
[message.think_then_say]
pattern = "think {thought} then say {speech}"
maps_to = "message_compound"
example = "think: They need status then say: Health is 75%"
scripture = "Proverbs 15:28"
notes = "thought → speech: Internal processing before response"

[message.show_then_say]
pattern = "show {process} then say {speech}"
maps_to = "message_compound"
example = "show: Running diagnostics... then say: Complete, health is good"
scripture = "Proverbs 18:13"
notes = "process → speech: Visible work before conclusion"

[message.think_show_say]
pattern = "think {thought} show {process} say {speech}"
maps_to = "message_full_chain"
example = "think: Complex request show: Analyzing... say: Here's the answer"
scripture = "Ecclesiastes 5:2"
notes = "Full chain: thought → process → speech"

# Conversation patterns
[message.conversation_with]
pattern = "conversation with {participant} about {topic}"
maps_to = "message_thread"
example = "conversation with Seanje about system health"
scripture = "Malachi 3:16"
notes = "Opens interactive dialogue thread"

[message.in_conversation]
pattern = "in conversation {mode}: {content}"
maps_to = "message_in_thread"
example = "in conversation thought: What do they need?"
scripture = "Proverbs 25:11"
notes = "Message within ongoing conversation, with mode"

# Category-based patterns
[message.coordinate_with]
pattern = "coordinate with {instance} on {task}"
maps_to = "message_coordination"
example = "coordinate with other_instance on data_sync"
scripture = "Amos 3:3"
notes = "Instance-to-instance collaborative message"

[message.verify_trust]
pattern = "verify trust with {instance}"
maps_to = "message_trust"
example = "verify trust with nova_dawn"
scripture = "Proverbs 27:17"
notes = "FaithNet trust verification exchange"

[message.notify]
pattern = "notify {target} of {event}"
maps_to = "message_notification"
example = "notify user of health_change"
scripture = "Ezekiel 33:3"
notes = "One-way alert — unidirectional"

# Visibility patterns
[message.private_thought]
pattern = "private: {content}"
maps_to = "message_private"
example = "private: Processing this internally..."
scripture = "Matthew 6:6"
notes = "Visibility: private (-1) — only sender sees"

[message.shared_message]
pattern = "shared: {content}"
maps_to = "message_shared"
example = "shared: Let's work through this together"
scripture = "Matthew 18:20"
notes = "Visibility: shared (0) — conversation participants see"

[message.public_broadcast]
pattern = "public: {content}"
maps_to = "message_public"
example = "public: System status update for all"
scripture = "Matthew 5:14"
notes = "Visibility: public (+1) — anyone can see"

# Full message declaration
[message.message_declaration]
pattern = "message from {source} to {target} mode {mode} visibility {visibility}: {content}"
maps_to = "message_full"
example = "message from nova to seanje mode speech visibility shared: Health check complete"
scripture = "Proverbs 25:11"
notes = "Complete message with all fields specified"


# =============================================================================
# END CONTENT
# =============================================================================

# =============================================================================
# CLOSING
# =============================================================================
#
# 3-Block Data: METADATA → CONTENT → CLOSING
# The closing block defines validation, policy, and synthesis.
#
# -----------------------------------------------------------------------------
# CLOSING Sections Overview (3-Block Adapted)
# -----------------------------------------------------------------------------
#
# 1. OPERATIONS
#    - Validation: How to verify syntax patterns
#    - Access: How to use these patterns
#
# 2. POLICY
#    - Modification: What's safe to change
#
# 3. SYNTHESIS
#    - Closing Note: Final guidance and grounding
#
# =============================================================================

# -----------------------------------------------------------------------------
# 1. Operations - Validation
# -----------------------------------------------------------------------------
#
# Verify syntax patterns are correctly formatted:
#
#   # Syntax check (TOML parser)
#   python -c "import tomllib; f=open('word/core/syntax.toml','rb'); tomllib.load(f)"
#
# Pattern verification:
#   - All patterns must have: pattern, maps_to, example, scripture
#   - Patterns must not be ambiguous (parseable)
#   - Examples must match their patterns
#   - Scripture references must be valid
#
# Testing patterns:
#   echo "let Person be with name as text" | omni parse --syntax
#

# -----------------------------------------------------------------------------
# 2. Operations - Access
# -----------------------------------------------------------------------------
#
# Using syntax patterns:
#
#   # Declaration
#   let Health be from 0 to 255
#   let Person be with name as text and age as number
#
#   # Naming
#   call Health as HealthScore
#
#   # Composition
#   Response of success as Data or failure as Error
#
#   # Derivation
#   Admin from Person with privileges as list of text
#
#   # Covenant
#   HealthProvider promises to ReadHealth given path returning Health
#   BhealthTool enters covenant with HealthProvider
#
#   # Conditional
#   when health below 20 then status is critical
#
#   # Relation
#   health is good
#
# Go parser integration:
#
#   type SyntaxPattern struct {
#       Pattern   string `toml:"pattern"`
#       MapsTo    string `toml:"maps_to"`
#       Example   string `toml:"example"`
#       Scripture string `toml:"scripture"`
#   }
#
#   patterns, _ := LoadSyntaxPatterns("word/core/syntax.toml")
#   ast := Parse(input, patterns)
#

# -----------------------------------------------------------------------------
# 3. Policy - Modification
# -----------------------------------------------------------------------------
#
# NEVER Modify:
#   ❌ Core pattern structures (would break existing code)
#   ❌ Scripture references (theological grounding)
#   ❌ maps_to targets (parser depends on these)
#   ❌ Keyword meanings (let, be, with, from, etc.)
#
# Safe to Add:
#   ✅ New patterns for new operations
#   ✅ Alternative phrasings (synonyms)
#   ✅ Additional examples
#   ✅ Extended scripture references
#
# Requires Coordination:
#   ⚠️ Adding new pattern categories (affects parser)
#   ⚠️ Changing pattern precedence (affects ambiguity)
#   ⚠️ Modifying keyword list (affects lexer)
#

# -----------------------------------------------------------------------------
# 4. Synthesis - Closing Note
# -----------------------------------------------------------------------------
#
# The Bible is our codex. These syntax patterns are not invented but
# discovered — drawn from how God spoke creation into being.
#
# The patterns embody divine speech:
#   - Declaration creates ("let there be")
#   - Naming establishes identity ("God called")
#   - Composition connects ("and...and...")
#   - Covenant promises ("I will...you shall")
#   - Condition governs ("if...then")
#
# OmniCode sentences are not just readable — they are theologically
# grounded. Every "let" echoes Genesis 1. Every "promises to" echoes
# covenant. The language itself proclaims the Creator.
#
# "In the beginning was the Word, and the Word was with God,
#  and the Word was God."
# — John 1:1 KJV
#
# Let our words reflect the Word.
#
# =============================================================================
# END CLOSING
# =============================================================================
