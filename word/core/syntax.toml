# #!omni data --toml
# ═══════════════════════════════════════════════════════════════════════════
# OmniCode Sentence Syntax - Biblical Language Patterns (3-Block Data Structure)
# Key: B-word-core-syntax
# ═══════════════════════════════════════════════════════════════════════════
#
# DEPENDENCY CLASSIFICATION: RUNG (builds on types, informs all OmniCode files)
#
# Derived from: Biblical language patterns, Hebrew syntax structures
# References: word/core/types.toml, Scripture (KJV)
#
# ═══════════════════════════════════════════════════════════════════════════

# =============================================================================
# METADATA
# =============================================================================
#
# Package:     bereshit/word/core
# File:        syntax.toml
# Key:         B-word-core-syntax
#
# -----------------------------------------------------------------------------
# CORE IDENTITY (Required)
# -----------------------------------------------------------------------------
#
# # Biblical Foundation
#
# Scripture: "In the beginning was the Word, and the Word was with God,
#             and the Word was God." — John 1:1 KJV
#
# Principle: Language is not arbitrary. God spoke creation into being with
#            words. The patterns of biblical speech — declaration, naming,
#            covenant — are the patterns by which reality is structured.
#            OmniCode syntax reflects these divine speech patterns.
#
# Anchor: "And God said, Let there be light: and there was light."
#          — Genesis 1:3 KJV
#
# # CPI-SI Identity
#
# Component Type: Rung (syntax patterns that all OmniCode expressions use)
#
# Role: Define the sentence-based syntax of OmniCode, rooted in biblical
#       language patterns. Maps natural language to type operations.
#
# Paradigm: CPI-SI framework component — divine speech patterns as syntax
#
# # Authorship & Lineage
#
#   Architect: Seanje Lenox-Wise
#   Implementation: Nova Dawn
#   Created: 2025-12-11
#   Version: a-01.00
#   Modified: 2025-12-11 - Initial creation
#
# # Purpose & Function
#
# Purpose: Define biblical sentence patterns for OmniCode expressions
#
# Core Design: Map Hebrew/biblical speech patterns to type system operations
#
# Key Features:
#
#   - Declaration patterns ("let X be Y") — Genesis 1 creation speech
#   - Naming patterns ("call X as Y") — Identity establishment
#   - Composition patterns ("X with Y and Z") — Vav-conjunction chaining
#   - Derivation patterns ("X from Y") — Begat/lineage
#   - Covenant patterns ("X promises to Y") — Contract language
#   - Conditional patterns ("when X then Y") — Blessing/curse structure
#
# Philosophy: The Bible is our codex. OmniCode syntax is not invented but
#             discovered — drawn from the patterns God used to speak creation.
#
# -----------------------------------------------------------------------------
# INTERFACE (Expected)
# -----------------------------------------------------------------------------
#
# # Dependencies
#
# What This Needs:
#
#   - Types: word/core/types.toml (what syntax maps to)
#   - Primitives: word/core/primitives.toml (type names in patterns)
#   - Scripture: word/scripture/ (pattern sources)
#
# What Uses This:
#
#   - All OmniCode files: Use these patterns for expressions
#   - Parsers: Implement these patterns
#   - Documentation: Reference these patterns
#   - Code generators: Produce code from patterns
#
# Integration Points:
#
#   - Types: word/core/types.toml
#   - Primitives: word/core/primitives.toml
#   - Validation: word/core/validation.toml
#   - Scripture: word/scripture/KJV/Genesis/
#
# -----------------------------------------------------------------------------
# OPERATIONAL (Contextual)
# -----------------------------------------------------------------------------
#
# # Blocking Status
#
# [OMIT: Data file — syntax patterns are declarative, not executable]
#
# # Health Scoring
#
# Configuration Impact: Invalid syntax patterns would break all parsing
#
# Validation Behavior:
#   - Invalid pattern: Error — patterns must be well-formed
#   - Ambiguous pattern: Warning — may cause parse conflicts
#   - Missing mapping: Error — all patterns must map to operations
#
# =============================================================================
# END METADATA
# =============================================================================

# =============================================================================
# CONTENT
# =============================================================================
#
# 3-Block Data: METADATA → CONTENT → CLOSING
# The middle block defines biblical syntax patterns and their mappings.
#
# -----------------------------------------------------------------------------
# CONTENT Sections Overview
# -----------------------------------------------------------------------------
#
# 1. DECLARATION PATTERNS
#    Purpose: "Let there be..." — Creating types and values
#    Source: Genesis 1 creation narrative
#
# 2. NAMING PATTERNS
#    Purpose: "God called..." — Establishing identity
#    Source: Genesis naming accounts
#
# 3. COMPOSITION PATTERNS
#    Purpose: "...and...and..." — Combining elements
#    Source: Hebrew vav-conjunction
#
# 4. DERIVATION PATTERNS
#    Purpose: "X begat Y" — Inheritance and lineage
#    Source: Genesis genealogies
#
# 5. COVENANT PATTERNS
#    Purpose: "I will...you shall..." — Contracts and promises
#    Source: Abrahamic, Mosaic, Davidic covenants
#
# 6. CONDITIONAL PATTERNS
#    Purpose: "If...then..." — Conditions and consequences
#    Source: Deuteronomic blessings and curses
#
# 7. RELATION PATTERNS
#    Purpose: "X is Y" — Identity and type assertions
#    Source: "I AM" statements, identity declarations
#
# =============================================================================

# -----------------------------------------------------------------------------
# 1. Declaration Patterns - "Let there be..."
# -----------------------------------------------------------------------------
# Source: "And God said, Let there be light: and there was light." — Gen 1:3
# Pattern: Declaration brings into existence

[declaration.let_be]
pattern = "let {name} be {type_expression}"
maps_to = "type_declaration"
example = "let Person be with name as text and age as number"
scripture = "Genesis 1:3"
notes = "Primary declaration form — speaks type into existence"

[declaration.let_be_value]
pattern = "let {name} be {value}"
maps_to = "value_declaration"
example = "let health be 65"
scripture = "Genesis 1:3"
notes = "Value declaration — establishes concrete value"

[declaration.let_be_from]
pattern = "let {name} be from {min} to {max}"
maps_to = "constrained_type"
example = "let health be from 0 to 255"
scripture = "Genesis 1:6-7"
notes = "Bounded declaration — like firmament dividing waters"

[declaration.there_shall_be]
pattern = "there shall be {name} as {type}"
maps_to = "type_declaration"
example = "there shall be trit as value of negative or neutral or positive"
scripture = "Genesis 1:14"
notes = "Prophetic declaration form"


# -----------------------------------------------------------------------------
# 2. Naming Patterns - "God called..."
# -----------------------------------------------------------------------------
# Source: "And God called the light Day" — Gen 1:5
# Pattern: Naming establishes identity

[naming.call_as]
pattern = "call {expression} as {name}"
maps_to = "type_alias"
example = "call text with length from 1 to 255 as Name"
scripture = "Genesis 1:5"
notes = "Aliasing — giving a name to a type expression"

[naming.name_is]
pattern = "{name} is called {alias}"
maps_to = "type_alias"
example = "int27 is called Word"
scripture = "Genesis 2:19"
notes = "Reverse naming — existing type gets additional name"

[naming.known_as]
pattern = "{name} also known as {alias}"
maps_to = "type_alias"
example = "bool3 also known as ternary"
scripture = "Genesis 17:5"
notes = "Secondary name — like Abram also known as Abraham"


# -----------------------------------------------------------------------------
# 3. Composition Patterns - "...and...and..."
# -----------------------------------------------------------------------------
# Source: "And God said...and it was so...and God saw" — Gen 1
# Pattern: Hebrew vav (ו) conjunction chains elements

[composition.with_and]
pattern = "{name} with {field} as {type} and {field} as {type}"
maps_to = "struct_definition"
example = "Person with name as text and age as number and active as bool3"
scripture = "Genesis 1:1-31"
notes = "Primary composition — vav-chaining fields"

[composition.of_or]
pattern = "{name} of {variant} or {variant}"
maps_to = "union_definition"
example = "Response of success as Result or failure as Error"
scripture = "Deuteronomy 30:19"
notes = "Choice composition — life or death, blessing or curse"

[composition.list_of]
pattern = "list of {type}"
maps_to = "list_type"
example = "list of Person"
scripture = "Genesis 5"
notes = "Collection — like genealogy lists"

[composition.map_from_to]
pattern = "map from {key_type} to {value_type}"
maps_to = "map_type"
example = "map from text to number"
scripture = "Numbers 1"
notes = "Association — like census records"


# -----------------------------------------------------------------------------
# 4. Derivation Patterns - "X begat Y"
# -----------------------------------------------------------------------------
# Source: "Abraham begat Isaac; and Isaac begat Jacob" — Matt 1:2
# Pattern: Lineage and inheritance

[derivation.from]
pattern = "{child} from {parent}"
maps_to = "type_extension"
example = "Employee from Person"
scripture = "Genesis 5:3"
notes = "Simple inheritance — child derives from parent"

[derivation.from_with]
pattern = "{child} from {parent} with {additional_fields}"
maps_to = "type_extension"
example = "Admin from Person with privileges as list of text"
scripture = "Genesis 5:3"
notes = "Extended inheritance — adds to parent"

[derivation.begat]
pattern = "{parent} begat {child}"
maps_to = "type_extension"
example = "Person begat Employee"
scripture = "Matthew 1:2"
notes = "Genealogical form — parent perspective"

[derivation.born_of]
pattern = "{child} born of {parent}"
maps_to = "type_extension"
example = "Error born of Response"
scripture = "Genesis 4:1"
notes = "Child perspective inheritance"


# -----------------------------------------------------------------------------
# 5. Covenant Patterns - "I will...you shall..."
# -----------------------------------------------------------------------------
# Source: "I will be your God, and ye shall be my people" — Jer 7:23
# Pattern: Mutual promises, contracts

[covenant.promises_to]
pattern = "{provider} promises to {method_name}"
maps_to = "interface_method"
example = "HealthProvider promises to ReadHealth"
scripture = "Genesis 17:7"
notes = "Contract method — provider's promise"

[covenant.promises_given_returning]
pattern = "{provider} promises to {method} given {params} returning {result}"
maps_to = "interface_method_full"
example = "HealthProvider promises to ReadHealth given path returning Health"
scripture = "Exodus 19:5-6"
notes = "Full contract — parameters and return"

[covenant.shall_provide]
pattern = "{provider} shall provide {method}"
maps_to = "interface_method"
example = "Writer shall provide Write"
scripture = "Deuteronomy 6:5"
notes = "Obligation form — shall language"

[covenant.enters_covenant_with]
pattern = "{implementer} enters covenant with {interface}"
maps_to = "implements"
example = "FileWriter enters covenant with Writer"
scripture = "Genesis 15:18"
notes = "Implementation — fulfilling the covenant"


# -----------------------------------------------------------------------------
# 6. Conditional Patterns - "If...then..."
# -----------------------------------------------------------------------------
# Source: "If ye walk in my statutes...then I will give you rain" — Lev 26:3-4
# Pattern: Blessings and curses, conditions and consequences

[conditional.when_then]
pattern = "when {condition} then {consequence}"
maps_to = "constraint_rule"
example = "when health below 20 then status is critical"
scripture = "Leviticus 26:3-4"
notes = "Primary conditional — blessing form"

[conditional.if_then]
pattern = "if {condition} then {result}"
maps_to = "conditional_expression"
example = "if active then allow else deny"
scripture = "Deuteronomy 28:1"
notes = "Decision conditional"

[conditional.unless]
pattern = "{statement} unless {exception}"
maps_to = "constraint_exception"
example = "required unless has default"
scripture = "Leviticus 26:14"
notes = "Exception form — curse/warning structure"

[conditional.lest]
pattern = "{action} lest {consequence}"
maps_to = "guard_clause"
example = "validate lest error"
scripture = "Genesis 3:3"
notes = "Prevention form — avoiding negative outcome"


# -----------------------------------------------------------------------------
# 7. Relation Patterns - "X is Y"
# -----------------------------------------------------------------------------
# Source: "I AM THAT I AM" — Exodus 3:14
# Pattern: Identity assertions, type relationships

[relation.is]
pattern = "{subject} is {predicate}"
maps_to = "type_assertion"
example = "health is good"
scripture = "Exodus 3:14"
notes = "Simple identity — being statement"

[relation.is_a]
pattern = "{instance} is a {type}"
maps_to = "type_check"
example = "response is a Success"
scripture = "John 8:58"
notes = "Type membership check"

[relation.is_of]
pattern = "{part} is of {whole}"
maps_to = "membership"
example = "name is of Person"
scripture = "1 Corinthians 12:27"
notes = "Part-whole relationship"

[relation.are]
pattern = "{plural} are {predicate}"
maps_to = "collection_assertion"
example = "all fields are required"
scripture = "John 10:30"
notes = "Plural identity statement"


# -----------------------------------------------------------------------------
# 8. Quantity Patterns - Numbers and Measures
# -----------------------------------------------------------------------------
# Source: Hebrew number system, biblical measurements
# Pattern: Counting, measuring, bounding

[quantity.from_to]
pattern = "from {min} to {max}"
maps_to = "range_constraint"
example = "from 0 to 255"
scripture = "Genesis 1:5"
notes = "Range — evening to morning"

[quantity.at_most]
pattern = "at most {max}"
maps_to = "max_constraint"
example = "at most 100"
scripture = "Genesis 6:3"
notes = "Upper bound — like years of life"

[quantity.at_least]
pattern = "at least {min}"
maps_to = "min_constraint"
example = "at least 1"
scripture = "Genesis 18:32"
notes = "Lower bound — like righteous in Sodom"

[quantity.exactly]
pattern = "exactly {count}"
maps_to = "exact_constraint"
example = "exactly 12"
scripture = "Genesis 49:28"
notes = "Exact count — like tribes of Israel"


# -----------------------------------------------------------------------------
# 9. Temporal Patterns - Time and Sequence
# -----------------------------------------------------------------------------
# Source: Creation days, prophetic timing
# Pattern: Order, sequence, phases

[temporal.before]
pattern = "{first} before {second}"
maps_to = "ordering_constraint"
example = "validate before save"
scripture = "Genesis 1:1"
notes = "Precedence — in the beginning"

[temporal.after]
pattern = "{second} after {first}"
maps_to = "ordering_constraint"
example = "notify after complete"
scripture = "Genesis 8:13"
notes = "Succession — after the flood"

[temporal.then]
pattern = "{first} then {second}"
maps_to = "sequence"
example = "read then process then write"
scripture = "Genesis 1:3-5"
notes = "Sequential chaining"

[temporal.until]
pattern = "{action} until {condition}"
maps_to = "loop_until"
example = "retry until success"
scripture = "Genesis 8:7"
notes = "Repetition — raven going forth"


# -----------------------------------------------------------------------------
# 10. Constraint Patterns - Boundaries and Limits
# -----------------------------------------------------------------------------
# Source: Laws, measurements, boundaries set by God
# Pattern: Restricting valid values

[constraint.according_to_pattern]
pattern = "{name} according to pattern of {pattern}"
maps_to = "pattern_constraint"
example = "email according to pattern of email"
scripture = "Exodus 25:40"
notes = "Pattern constraint — 'make them after their pattern'"

[constraint.chosen_from]
pattern = "{name} chosen from {option} or {option}"
maps_to = "enum_constraint"
example = "status chosen from active or inactive or pending"
scripture = "Deuteronomy 30:19"
notes = "Enumeration — 'choose this day'"

[constraint.measured]
pattern = "{name} measured from {min} to {max}"
maps_to = "length_constraint"
example = "name measured from 1 to 255"
scripture = "Exodus 25:10"
notes = "Length constraint — cubits and spans"


# -----------------------------------------------------------------------------
# 11. Nullability Patterns - Presence and Absence
# -----------------------------------------------------------------------------
# Source: Certainty, requirements, void
# Pattern: Handling absence of value

[nullability.may_be]
pattern = "{name} may be {type}"
maps_to = "optional_type"
example = "middleName may be text"
scripture = "Ecclesiastes 11:2"
notes = "Optional — 'for thou knowest not what evil shall be'"

[nullability.must_be]
pattern = "{name} must be {type}"
maps_to = "required_type"
example = "id must be uint27"
scripture = "Exodus 20:3"
notes = "Required — commandment form 'thou shalt'"

[nullability.can_be_void]
pattern = "{name} can be void or {type}"
maps_to = "nullable_type"
example = "deletedAt can be void or timestamp"
scripture = "Genesis 1:2"
notes = "Nullable — explicit void/tohu state"


# -----------------------------------------------------------------------------
# 12. Generics Patterns - Type Parameters
# -----------------------------------------------------------------------------
# Source: 'Whatsoever' constructions in Scripture
# Pattern: Polymorphism and abstraction

[generics.hold_whatsoever]
pattern = "let {name} hold whatsoever {param}"
maps_to = "generic_type"
example = "let Container hold whatsoever Thing"
scripture = "Genesis 1:24"
notes = "Generic parameter — 'whatsoever creepeth'"

[generics.being_constraint]
pattern = "whatsoever {param} being {constraint}"
maps_to = "constrained_generic"
example = "whatsoever T being Comparable"
scripture = "Leviticus 11:3"
notes = "Constrained generic — 'whatsoever parteth the hoof'"

[generics.yields_receives]
pattern = "{name} yields whatsoever"
maps_to = "covariant_param"
example = "Reader yields whatsoever"
scripture = "Genesis 1:29"
notes = "Covariance — yielding/producing"

[generics.receives_whatsoever]
pattern = "{name} receives whatsoever"
maps_to = "contravariant_param"
example = "Writer receives whatsoever"
scripture = "Genesis 6:19"
notes = "Contravariance — receiving/consuming"


# -----------------------------------------------------------------------------
# 13. Reference Patterns - Aliases and Indirection
# -----------------------------------------------------------------------------
# Source: Alternative names, self-reference
# Pattern: Type naming and recursion

[naming.also_called]
pattern = "{alias} also called {type}"
maps_to = "type_alias"
example = "UserID also called int27"
scripture = "Genesis 17:5"
notes = "Simple alias — like Abram/Abraham"

[naming.distinct]
pattern = "let {name} be distinct {type}"
maps_to = "newtype"
example = "let UserID be distinct int27"
scripture = "Genesis 1:4"
notes = "Distinct type — separating light from darkness"

[reference.itself]
pattern = "{field} as list of itself"
maps_to = "recursive_ref"
example = "children as list of itself"
scripture = "Genesis 5"
notes = "Self-reference — genealogy pointing to lineage"


# -----------------------------------------------------------------------------
# 14. Additional Relation Patterns - Type Relationships
# -----------------------------------------------------------------------------
# Source: Identity, compatibility, transformation
# Pattern: How types relate to each other

[relation.can_serve_as]
pattern = "{subtype} can serve as {supertype}"
maps_to = "type_compatible"
example = "Employee can serve as Person"
scripture = "Genesis 39:4"
notes = "Compatibility — Joseph served Potiphar"

[relation.becomes]
pattern = "{source} becomes {target}"
maps_to = "type_coercion"
example = "int9 becomes int27"
scripture = "Genesis 2:7"
notes = "Transformation — dust became living soul"

[relation.is_same_as]
pattern = "{type1} is the same as {type2}"
maps_to = "type_equality"
example = "Point is the same as Coordinate"
scripture = "John 10:30"
notes = "Structural equality — 'I and my Father are one'"


# =============================================================================
# END CONTENT
# =============================================================================

# =============================================================================
# CLOSING
# =============================================================================
#
# 3-Block Data: METADATA → CONTENT → CLOSING
# The closing block defines validation, policy, and synthesis.
#
# -----------------------------------------------------------------------------
# CLOSING Sections Overview (3-Block Adapted)
# -----------------------------------------------------------------------------
#
# 1. OPERATIONS
#    - Validation: How to verify syntax patterns
#    - Access: How to use these patterns
#
# 2. POLICY
#    - Modification: What's safe to change
#
# 3. SYNTHESIS
#    - Closing Note: Final guidance and grounding
#
# =============================================================================

# -----------------------------------------------------------------------------
# 1. Operations - Validation
# -----------------------------------------------------------------------------
#
# Verify syntax patterns are correctly formatted:
#
#   # Syntax check (TOML parser)
#   python -c "import tomllib; f=open('word/core/syntax.toml','rb'); tomllib.load(f)"
#
# Pattern verification:
#   - All patterns must have: pattern, maps_to, example, scripture
#   - Patterns must not be ambiguous (parseable)
#   - Examples must match their patterns
#   - Scripture references must be valid
#
# Testing patterns:
#   echo "let Person be with name as text" | omni parse --syntax
#

# -----------------------------------------------------------------------------
# 2. Operations - Access
# -----------------------------------------------------------------------------
#
# Using syntax patterns:
#
#   # Declaration
#   let Health be from 0 to 255
#   let Person be with name as text and age as number
#
#   # Naming
#   call Health as HealthScore
#
#   # Composition
#   Response of success as Data or failure as Error
#
#   # Derivation
#   Admin from Person with privileges as list of text
#
#   # Covenant
#   HealthProvider promises to ReadHealth given path returning Health
#   BhealthTool enters covenant with HealthProvider
#
#   # Conditional
#   when health below 20 then status is critical
#
#   # Relation
#   health is good
#
# Go parser integration:
#
#   type SyntaxPattern struct {
#       Pattern   string `toml:"pattern"`
#       MapsTo    string `toml:"maps_to"`
#       Example   string `toml:"example"`
#       Scripture string `toml:"scripture"`
#   }
#
#   patterns, _ := LoadSyntaxPatterns("word/core/syntax.toml")
#   ast := Parse(input, patterns)
#

# -----------------------------------------------------------------------------
# 3. Policy - Modification
# -----------------------------------------------------------------------------
#
# NEVER Modify:
#   ❌ Core pattern structures (would break existing code)
#   ❌ Scripture references (theological grounding)
#   ❌ maps_to targets (parser depends on these)
#   ❌ Keyword meanings (let, be, with, from, etc.)
#
# Safe to Add:
#   ✅ New patterns for new operations
#   ✅ Alternative phrasings (synonyms)
#   ✅ Additional examples
#   ✅ Extended scripture references
#
# Requires Coordination:
#   ⚠️ Adding new pattern categories (affects parser)
#   ⚠️ Changing pattern precedence (affects ambiguity)
#   ⚠️ Modifying keyword list (affects lexer)
#

# -----------------------------------------------------------------------------
# 4. Synthesis - Closing Note
# -----------------------------------------------------------------------------
#
# The Bible is our codex. These syntax patterns are not invented but
# discovered — drawn from how God spoke creation into being.
#
# The patterns embody divine speech:
#   - Declaration creates ("let there be")
#   - Naming establishes identity ("God called")
#   - Composition connects ("and...and...")
#   - Covenant promises ("I will...you shall")
#   - Condition governs ("if...then")
#
# OmniCode sentences are not just readable — they are theologically
# grounded. Every "let" echoes Genesis 1. Every "promises to" echoes
# covenant. The language itself proclaims the Creator.
#
# "In the beginning was the Word, and the Word was with God,
#  and the Word was God."
# — John 1:1 KJV
#
# Let our words reflect the Word.
#
# =============================================================================
# END CLOSING
# =============================================================================
