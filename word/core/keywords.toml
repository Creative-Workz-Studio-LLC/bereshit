# #!omni data --toml
# ═══════════════════════════════════════════════════════════════════════════
# OmniCode Keyword Lexicon (3-Block Data Structure)
# Key: B-word-core-keywords
# ═══════════════════════════════════════════════════════════════════════════
#
# DEPENDENCY CLASSIFICATION: LADDER (foundation that syntax.toml builds on)
#
# Derived from: OmniCode 3-block data structure
# References: word/core/syntax.toml (patterns use these keywords)
#
# ═══════════════════════════════════════════════════════════════════════════

# =============================================================================
# METADATA
# =============================================================================
#
# Package:     bereshit/word/core
# File:        keywords.toml
# Key:         B-word-core-keywords
#
# -----------------------------------------------------------------------------
# CORE IDENTITY (Required)
# -----------------------------------------------------------------------------
#
# # Biblical Foundation
#
# Scripture: "In the beginning was the Word, and the Word was with God,
#             and the Word was God." — John 1:1 KJV
#
# Principle: Words have power. God spoke creation into existence. Keywords
#            are the vocabulary of OmniCode — each word carries meaning
#            rooted in Scripture, not invented but discovered.
#
# Anchor: "So shall my word be that goeth forth out of my mouth: it shall
#          not return unto me void." — Isaiah 55:11 KJV
#
# # CPI-SI Identity
#
# Component Type: Ladder (keyword vocabulary that syntax patterns use)
#
# Role: Keyword definitions for OmniCode — the reserved words that form
#       the vocabulary of the sentence-based syntax. Each keyword maps
#       to biblical language patterns.
#
# Paradigm: CPI-SI framework component — words as stored truth
#
# # Authorship & Lineage
#
#   Architect: Seanje Lenox-Wise
#   Implementation: Nova Dawn
#   Created: 2025-12-11
#   Version: a-01.00
#   Modified: 2025-12-11 - Initial creation
#
# # Purpose & Function
#
# Purpose: Define the reserved keywords that OmniCode syntax patterns use
#
# Core Design: Vocabulary lexicon — words that have special meaning in OmniCode
#
# Key Features:
#
#   - Declaration keywords (let, be, there, shall)
#   - Composition keywords (with, and, or, of)
#   - Covenant keywords (promises, given, returning, enters, covenant)
#   - Relation keywords (is, as, from, to)
#   - Conditional keywords (when, then, lest)
#   - Nullability keywords (may, must, void, can)
#   - Generic keywords (whatsoever, being)
#
# Philosophy: Keywords are not invented — they are discovered from Scripture.
#             Each word carries the weight of its biblical usage.
#
# -----------------------------------------------------------------------------
# INTERFACE (Expected)
# -----------------------------------------------------------------------------
#
# # Dependencies
#
# What This Needs:
#
#   - Parser: Any TOML library (BurntSushi/toml, pelletier/go-toml)
#
# What Uses This:
#
#   - word/core/syntax.toml: Pattern definitions use these keywords
#   - Lexer: Tokenizes keywords during parsing
#   - Compiler: Keyword recognition and validation
#   - IDE: Syntax highlighting for keywords
#
# Integration Points:
#
#   - Syntax: word/core/syntax.toml (patterns reference keywords)
#   - Types: word/core/types.toml (type syntax uses keywords)
#   - Contracts: word/core/contracts/* (covenant keywords)
#
# -----------------------------------------------------------------------------
# OPERATIONAL (Contextual)
# -----------------------------------------------------------------------------
#
# # Blocking Status
#
# [OMIT: Data file — keywords are declarative, not executable]
#
# # Health Scoring
#
# Configuration Impact: Invalid keywords would break all parsing
#
# Validation Behavior:
#   - Invalid keyword: Error — reserved words are fixed
#   - Missing category: Warning — may indicate incomplete lexicon
#   - Duplicate keyword: Error — each word must be unique
#
# =============================================================================
# END METADATA
# =============================================================================

# =============================================================================
# CONTENT
# =============================================================================
#
# 3-Block Data: METADATA → CONTENT → CLOSING
# The middle block defines the keywords and their properties.
#
# -----------------------------------------------------------------------------
# CONTENT Sections Overview
# -----------------------------------------------------------------------------
#
# 1. DECLARATION KEYWORDS
#    Purpose: Words for creating types and values (let, be, there, shall)
#
# 2. COMPOSITION KEYWORDS
#    Purpose: Words for combining elements (with, and, or, of)
#
# 3. COVENANT KEYWORDS
#    Purpose: Words for contracts/interfaces (promises, given, returning, enters)
#
# 4. RELATION KEYWORDS
#    Purpose: Words for type relationships (is, as, from, to)
#
# 5. CONDITIONAL KEYWORDS
#    Purpose: Words for conditions (when, then, lest)
#
# 6. NULLABILITY KEYWORDS
#    Purpose: Words for presence/absence (may, must, can, void)
#
# 7. GENERIC KEYWORDS
#    Purpose: Words for polymorphism (whatsoever, being)
#
# 8. DERIVATION KEYWORDS
#    Purpose: Words for inheritance (begat, extends, itself)
#
# =============================================================================

# -----------------------------------------------------------------------------
# 1. Declaration Keywords - Creating Types and Values
# -----------------------------------------------------------------------------
# Source: "Let there be light" — Genesis 1:3
# Pattern: Speaking things into existence

[declaration.let]
keyword = "let"
category = "declaration"
role = "introduces type or value declaration"
scripture = "Genesis 1:3"
scripture_text = "And God said, Let there be light"
example = "let Person be with name as text"
reserved = true

[declaration.be]
keyword = "be"
category = "declaration"
role = "establishes identity or assignment"
scripture = "Exodus 3:14"
scripture_text = "I AM THAT I AM"
example = "let health be 65"
reserved = true

[declaration.there]
keyword = "there"
category = "declaration"
role = "existential declaration (with shall)"
scripture = "Genesis 1:3"
scripture_text = "Let there be light"
example = "there shall be trit"
reserved = true

[declaration.shall]
keyword = "shall"
category = "declaration"
role = "prophetic/future declaration"
scripture = "Genesis 1:14"
scripture_text = "Let there be lights in the firmament"
example = "there shall be truth"
reserved = true


# -----------------------------------------------------------------------------
# 2. Composition Keywords - Combining Elements
# -----------------------------------------------------------------------------
# Source: Hebrew vav (ו) conjunction — "and...and...and"
# Pattern: Chaining elements together

[composition.with]
keyword = "with"
category = "composition"
role = "introduces fields in a struct"
scripture = "Genesis 1:1"
scripture_text = "In the beginning God created the heaven and the earth"
example = "Person with name as text and age as number"
reserved = true

[composition.and]
keyword = "and"
category = "composition"
role = "chains multiple elements (vav conjunction)"
scripture = "Genesis 1:1-31"
scripture_text = "And God said...and it was so...and God saw"
example = "name as text and age as number and active as bool3"
reserved = true

[composition.or]
keyword = "or"
category = "composition"
role = "alternation between options"
scripture = "Deuteronomy 30:19"
scripture_text = "I have set before you life and death, blessing and cursing"
example = "Response of success or failure"
reserved = true

[composition.of]
keyword = "of"
category = "composition"
role = "specifies contents or membership"
scripture = "Genesis 5:1"
scripture_text = "This is the book of the generations of Adam"
example = "list of Person"
reserved = true


# -----------------------------------------------------------------------------
# 3. Covenant Keywords - Contracts and Interfaces
# -----------------------------------------------------------------------------
# Source: "I will be your God, and ye shall be my people" — Jeremiah 7:23
# Pattern: Promises and obligations

[covenant.promises]
keyword = "promises"
category = "covenant"
role = "declares a method/capability that must be provided"
scripture = "Exodus 19:5-6"
scripture_text = "If ye will obey my voice indeed, and keep my covenant"
example = "HealthProvider promises to ReadHealth"
reserved = true

[covenant.given]
keyword = "given"
category = "covenant"
role = "specifies input parameters"
scripture = "Genesis 1:29"
scripture_text = "I have given you every herb bearing seed"
example = "promises to ReadHealth given path"
reserved = true

[covenant.returning]
keyword = "returning"
category = "covenant"
role = "specifies return value"
scripture = "Genesis 8:11"
scripture_text = "And the dove came in to him in the evening"
example = "given path returning Health"
reserved = true

[covenant.enters]
keyword = "enters"
category = "covenant"
role = "declares implementation of interface"
scripture = "Genesis 15:18"
scripture_text = "The LORD made a covenant with Abram"
example = "BhealthProvider enters covenant with HealthProvider"
reserved = true

[covenant.covenant]
keyword = "covenant"
category = "covenant"
role = "the interface/contract itself"
scripture = "Genesis 9:9"
scripture_text = "I establish my covenant with you"
example = "enters covenant with Writer"
reserved = true


# -----------------------------------------------------------------------------
# 4. Relation Keywords - Type Relationships
# -----------------------------------------------------------------------------
# Source: "I AM THAT I AM" — Exodus 3:14
# Pattern: Identity and relationship assertions

[relation.is]
keyword = "is"
category = "relation"
role = "asserts identity or type membership"
scripture = "Exodus 3:14"
scripture_text = "I AM THAT I AM"
example = "Admin is a Person"
reserved = true

[relation.as]
keyword = "as"
category = "relation"
role = "specifies type of a field or expression"
scripture = "Genesis 1:5"
scripture_text = "God called the light Day"
example = "name as text"
reserved = true

[relation.from]
keyword = "from"
category = "relation"
role = "source, minimum bound, or derivation"
scripture = "Genesis 2:7"
scripture_text = "The LORD God formed man of the dust of the ground"
example = "Employee from Person"
reserved = true

[relation.to]
keyword = "to"
category = "relation"
role = "destination or maximum bound"
scripture = "Genesis 1:5"
scripture_text = "And the evening and the morning were the first day"
example = "from 0 to 255"
reserved = true


# -----------------------------------------------------------------------------
# 5. Conditional Keywords - Conditions and Consequences
# -----------------------------------------------------------------------------
# Source: Blessings and curses — Deuteronomy 28
# Pattern: If-then consequences

[conditional.when]
keyword = "when"
category = "conditional"
role = "introduces a condition"
scripture = "Leviticus 26:3"
scripture_text = "If ye walk in my statutes"
example = "when health below 20 then status is critical"
reserved = true

[conditional.then]
keyword = "then"
category = "conditional"
role = "introduces consequence of condition"
scripture = "Leviticus 26:4"
scripture_text = "Then I will give you rain in due season"
example = "when condition then consequence"
reserved = true

[conditional.lest]
keyword = "lest"
category = "conditional"
role = "introduces negative consequence to avoid"
scripture = "Genesis 3:3"
scripture_text = "Lest ye die"
example = "validate lest error"
reserved = true


# -----------------------------------------------------------------------------
# 6. Nullability Keywords - Presence and Absence
# -----------------------------------------------------------------------------
# Source: Void/tohu, requirements, possibilities
# Pattern: Handling absence of value

[nullability.may]
keyword = "may"
category = "nullability"
role = "indicates optional (might not exist)"
scripture = "Ecclesiastes 11:2"
scripture_text = "For thou knowest not what evil shall be upon the earth"
example = "middleName may be text"
reserved = true

[nullability.must]
keyword = "must"
category = "nullability"
role = "indicates required (must exist)"
scripture = "Exodus 20:3"
scripture_text = "Thou shalt have no other gods before me"
example = "id must be uint27"
reserved = true

[nullability.can]
keyword = "can"
category = "nullability"
role = "indicates capability or nullable"
scripture = "Genesis 1:2"
scripture_text = "And the earth was without form, and void"
example = "deletedAt can be void or timestamp"
reserved = true

[nullability.void]
keyword = "void"
category = "nullability"
role = "explicit absence (tohu)"
scripture = "Genesis 1:2"
scripture_text = "And the earth was without form, and void (tohu)"
example = "can be void or text"
reserved = true


# -----------------------------------------------------------------------------
# 7. Generic Keywords - Polymorphism and Abstraction
# -----------------------------------------------------------------------------
# Source: "Whatsoever" constructions in Scripture
# Pattern: Type parameters and constraints

[generic.whatsoever]
keyword = "whatsoever"
category = "generic"
role = "type parameter placeholder"
scripture = "Genesis 2:19"
scripture_text = "Whatsoever Adam called every living creature"
example = "let Container hold whatsoever Thing"
reserved = true

[generic.being]
keyword = "being"
category = "generic"
role = "constrains a type parameter"
scripture = "Leviticus 11:3"
scripture_text = "Whatsoever parteth the hoof, and is clovenfooted"
example = "whatsoever T being Comparable"
reserved = true

[generic.hold]
keyword = "hold"
category = "generic"
role = "declares a generic type's parameter"
scripture = "Genesis 1:9"
scripture_text = "Let the waters...be gathered together unto one place"
example = "let Container hold whatsoever Thing"
reserved = true


# -----------------------------------------------------------------------------
# 8. Derivation Keywords - Inheritance and Reference
# -----------------------------------------------------------------------------
# Source: Genealogies — "Abraham begat Isaac"
# Pattern: Parent-child type relationships

[derivation.begat]
keyword = "begat"
category = "derivation"
role = "indicates type inheritance (parent produces child)"
scripture = "Matthew 1:2"
scripture_text = "Abraham begat Isaac; and Isaac begat Jacob"
example = "Person begat Employee"
reserved = true

[derivation.itself]
keyword = "itself"
category = "derivation"
role = "self-reference for recursive types"
scripture = "Genesis 5"
scripture_text = "And he begat sons and daughters"
example = "children as list of itself"
reserved = true

[derivation.distinct]
keyword = "distinct"
category = "derivation"
role = "creates new type wrapping another (newtype)"
scripture = "Genesis 1:4"
scripture_text = "And God divided the light from the darkness"
example = "let UserID be distinct int27"
reserved = true

[derivation.called]
keyword = "called"
category = "derivation"
role = "creates alias (another name)"
scripture = "Genesis 1:5"
scripture_text = "And God called the light Day"
example = "PathString also called text"
reserved = true

[derivation.also]
keyword = "also"
category = "derivation"
role = "introduces secondary name"
scripture = "Genesis 17:5"
scripture_text = "Neither shall thy name any more be called Abram"
example = "UserID also called int27"
reserved = true


# =============================================================================
# END CONTENT
# =============================================================================

# =============================================================================
# CLOSING
# =============================================================================
#
# 3-Block Data: METADATA → CONTENT → CLOSING
# The closing block defines validation, policy, and synthesis.
#
# -----------------------------------------------------------------------------
# CLOSING Sections Overview (3-Block Adapted)
# -----------------------------------------------------------------------------
#
# 1. OPERATIONS
#    - Validation: How to verify keywords are correct
#    - Access: How to read keyword definitions
#
# 2. POLICY
#    - Modification: What's safe to change
#
# 3. SYNTHESIS
#    - Closing Note: Final guidance and grounding
#
# =============================================================================

# -----------------------------------------------------------------------------
# 1. Operations - Validation
# -----------------------------------------------------------------------------
#
# Verify keywords are correctly formatted:
#
#   # Syntax check (TOML parser)
#   python -c "import tomllib; f=open('word/core/keywords.toml','rb'); tomllib.load(f)"
#
# Keyword verification:
#   - All keywords must have: keyword, category, role, scripture, example
#   - All keywords must be lowercase
#   - No duplicate keywords across categories
#   - All referenced scriptures must be valid
#

# -----------------------------------------------------------------------------
# 2. Operations - Access
# -----------------------------------------------------------------------------
#
# Go code integration:
#
#   type Keyword struct {
#       Keyword       string `toml:"keyword"`
#       Category      string `toml:"category"`
#       Role          string `toml:"role"`
#       Scripture     string `toml:"scripture"`
#       ScriptureText string `toml:"scripture_text"`
#       Example       string `toml:"example"`
#       Reserved      bool   `toml:"reserved"`
#   }
#
#   type Keywords struct {
#       Declaration map[string]Keyword `toml:"declaration"`
#       Composition map[string]Keyword `toml:"composition"`
#       Covenant    map[string]Keyword `toml:"covenant"`
#       // ... additional categories
#   }
#
#   cfg, _ := toml.LoadFile("word/core/keywords.toml")
#   letKeyword := cfg.Declaration["let"].Keyword  // "let"
#
# Lexer integration:
#
#   func IsKeyword(token string) bool {
#       _, exists := keywords[strings.ToLower(token)]
#       return exists
#   }
#

# -----------------------------------------------------------------------------
# 3. Policy - Modification
# -----------------------------------------------------------------------------
#
# NEVER Modify:
#   ❌ Core declaration keywords (let, be) — foundational to syntax
#   ❌ Scripture references — grounded in biblical truth
#   ❌ Reserved status — keywords must remain reserved
#   ❌ Existing keyword spellings — would break parsing
#
# Safe to Add:
#   ✅ New keywords (if biblically grounded)
#   ✅ Additional examples
#   ✅ Scripture text clarifications
#   ✅ Implementation notes
#
# Requires Coordination:
#   ⚠️ Adding new categories (affects lexer structure)
#   ⚠️ Changing keyword roles (affects syntax.toml patterns)
#   ⚠️ Adding keywords that conflict with primitives or types
#

# -----------------------------------------------------------------------------
# 4. Synthesis - Closing Note
# -----------------------------------------------------------------------------
#
# These keywords are the vocabulary of OmniCode. They are not invented —
# they are discovered from Scripture. Each word carries biblical weight.
#
# The keywords embody biblical language patterns:
#   - Declaration echoes Genesis 1 ("Let there be")
#   - Covenant echoes Exodus 19 ("I will be your God")
#   - Derivation echoes Matthew 1 ("Abraham begat Isaac")
#
# Dependencies flow upward:
#   keywords.toml → syntax.toml → types.toml → schemas/* → contracts/*
#
# Changes here ripple through all parsing. This is the lexicon.
#
# "In the beginning was the Word, and the Word was with God,
#  and the Word was God."
# — John 1:1 KJV
#
# Words have power. Use them wisely.
#
# =============================================================================
# END CLOSING
# =============================================================================
