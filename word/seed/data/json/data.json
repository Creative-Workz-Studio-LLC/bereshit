{
  "$pragma": "omni template --json",

  "_metadata": {
    "template_info": {
      "name": "JSON Data File (3-Block Structure for Simple Data)",
      "key": "B-word-seed-data-json-data",
      "is_template": true,
      "structure": "3-Block: METADATA → CONTENT → CLOSING",
      "dependency_classification": "[PURE/DEPENDED] - PURE: Self-contained data, DEPENDED: References other files",
      "description": "TEMPLATE file - copy and modify for new JSON data files. Replace all [bracketed] placeholders with actual content. Change pragma from 'template' to 'data' when complete.",
      "derived_from": "B-word-omni-seed-data-3block (OmniCode 3-block pattern)",
      "see": "bereshit/word/omni/seed/ for complete documentation",
      "adaptations": [
        "Language definition data (token types, keywords, operators)",
        "Compiler phase configuration tables",
        "AST node type definitions",
        "Code generation mappings",
        "Simple configuration and settings"
      ]
    },
    "core_identity": {
      "grounded_in": {
        "scripture": "[Relevant verse grounding this data file's purpose]",
        "from": "[Book Chapter:Verse in Translation]",
        "principle": "[Kingdom principle this data demonstrates]",
        "anchor": "[Supporting verse reinforcing the principle]",
        "anchor_from": "[Book Chapter:Verse in Translation]"
      },
      "serves_as": {
        "type": "[Ladder/Baton/Rails]",
        "type_guidance": {
          "Ladder": "Foundation data that other components build upon (token definitions, type mappings)",
          "Baton": "Transformation tables (syntax mappings, codegen tables)",
          "Rails": "Infrastructure data (logging formats, error codes)"
        },
        "role": "[Specific responsibility in system architecture]",
        "paradigm": "CPI-SI framework - Data as stored truth"
      },
      "authored_by": {
        "architect": "[Who designed the data structure]",
        "implementation": "[Who defined the values]",
        "created": "[YYYY-MM-DD]",
        "version": "[MAJOR.MINOR.PATCH]",
        "modified": "[YYYY-MM-DD - what changed]"
      },
      "exists_to": {
        "purpose": "[What does this data file define/configure?]",
        "design": "[Data pattern - e.g., 'Lookup table', 'Schema', 'Mapping']",
        "philosophy": "Language Definition in Data, Algorithm in Code",
        "features": [
          "[Major capability 1]",
          "[Major capability 2]",
          "[Major capability 3]"
        ],
        "what_stays_in_data": [
          "Token type definitions and categories",
          "Keyword lists and reserved words",
          "Operator precedence tables",
          "AST node type mappings",
          "Code generation templates"
        ],
        "what_stays_in_code": [
          "Parsing algorithms",
          "Type checking logic",
          "Code generation algorithms",
          "Error handling"
        ]
      }
    },
    "interface": {
      "identity": {
        "key": "[DATA-KEY-###]",
        "consumer": "[package that reads this - e.g., 'pkg/lexer', 'pkg/parser']",
        "loader": "[how it's loaded - e.g., 'embed.FS + json.Unmarshal']"
      },
      "depends_on": {
        "code": "[path/to/loader.go - Go code that processes this data]",
        "docs": "[path/to/documentation]",
        "schema": "[path/to/schema.json if applicable]"
      },
      "integrated_as": {
        "when": "[compile-time (embed) / runtime / on-demand]",
        "if_missing": "[compile error (embedded) / runtime panic / use defaults]",
        "validation": "[how data is validated - e.g., 'struct tags', 'custom validator']",
        "exits": {
          "valid": "data well-formed and complete",
          "partial": "data incomplete or has warnings",
          "invalid": "data corrupted or missing required fields"
        }
      }
    },
    "operational_context": {
      "blocking": {
        "status": "no",
        "because": "data is declarative, not executable",
        "mitigation": "validate data schema before use"
      },
      "health": {
        "data_impact": "[How invalid data affects system health]",
        "validation_behavior": {
          "invalid_entry": "[What happens - skip entry? error? use default?]",
          "missing_required": "[What happens - compile error? runtime panic?]",
          "type_mismatch": "[What happens - parse error? coercion?]"
        },
        "system": "Base100",
        "scale": "-100 to +100",
        "granted_above": "+50 meaning data valid and complete",
        "deferred_within": "±50 meaning data needs attention",
        "denied_below": "-50 meaning data invalid or corrupted"
      }
    }
  },

  "_content": {
    "schema": {
      "data_type": "[Type description - e.g., 'Token Definitions', 'Keyword Table']",
      "version": "[MAJOR.MINOR.PATCH]",
      "fields": {
        "[field_name]": {
          "type": "[type]",
          "meaning": "[Purpose of this field]",
          "default": "[default_value]"
        },
        "[field_name_2]": {
          "type": "[type]",
          "meaning": "[Purpose of this field]",
          "caution": "[Constraints on this field]"
        }
      },
      "constraints": {
        "[constraint_name]": {
          "ensuring": "[condition that must be true]",
          "because": "[why this constraint matters]"
        }
      }
    },
    "values": {
      "[data_section_1]": {
        "_comment": "Replace with actual data section name (e.g., 'tokens', 'keywords')",
        "[key]": "[value]",
        "[nested_key]": {
          "[inner_key]": "[inner_value]"
        }
      },
      "[data_section_2]": {
        "_comment": "Additional data section",
        "[array_key]": [
          "[item_1]",
          "[item_2]"
        ]
      }
    }
  },

  "_closing": {
    "operations": {
      "verified_by": {
        "syntax_check": "python -m json.tool [filename].json",
        "go_validation": "go test ./pkg/[consumer]/... -run TestDataLoad",
        "common_issues": {
          "parse_error": "Check for trailing commas (not allowed in JSON), missing quotes, bracket mismatches",
          "encoding": "Ensure UTF-8 encoding, no BOM",
          "type_mismatch": "Verify Go struct tags match JSON keys"
        }
      },
      "accessed_through": {
        "file_pattern": "[description]-data.json (e.g., token-data.json)",
        "embed_pattern": "//go:embed [filename].json\nvar dataFS embed.FS",
        "load_pattern": "json.Unmarshal(content, &data)",
        "consumer_pattern": "import \"[module]/pkg/[package]\""
      }
    },
    "policy": {
      "modification": {
        "safe": [
          "Add new entries following existing pattern",
          "Update values within documented constraints",
          "Add new sections if code supports them"
        ],
        "careful": [
          "Changing key names (breaks Go struct mapping)",
          "Changing value types (breaks json.Unmarshal)",
          "Removing entries (may break dependent code)"
        ],
        "never": [
          "3-block structure (_metadata, _content, _closing)",
          "Required keys without updating dependent code"
        ]
      },
      "future": {
        "planned": "[Planned additions - description]",
        "considered": "[Potential changes - why uncertain]",
        "rejected": "[Known limitations - why won't change]"
      }
    },
    "synthesis": {
      "overview": "See _metadata.core_identity.exists_to for purpose and philosophy",
      "schema": "See _content.schema for field definitions",
      "values": "See _content.values for actual data",
      "dependencies": "See _metadata.interface.depends_on for related files",
      "closing_note": {
        "scope": "This data file defines [describe scope]",
        "impact": "Changes affect [describe impact]",
        "scripture": "[Relevant closing Scripture]",
        "from": "[Book Chapter:Verse]"
      },
      "quick_reference": {
        "check": "python -m json.tool [filename].json",
        "import": "json.load(open('[path]'))",
        "access": "data['[field]']"
      }
    }
  }
}
