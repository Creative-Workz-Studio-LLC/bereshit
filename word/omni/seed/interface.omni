#!omni template

// ═══════════════════════════════════════════════════════════════════════════
// METADATA
// ═══════════════════════════════════════════════════════════════════════════

this is a template for "OmniCode Interface":
    keyed as "B-word-omni-seed-interface"
    following "3-Block Structure (Word)"

this template classifies as:
    independent (1) when "pure interface with no dependencies"
    connected (0) when "extending other interfaces" such as "[list them]"
    dependent (-1) when "requiring external type definitions" such as "[list them]"

this template derives from:
    original (1) when "establishing new interface pattern"
    derived (0) from "B-word-omni-seed-universal"
    variant (-1) when "intentionally departing from standard"
    documented at "bereshit/word/omni/seed/"

this template strictness is:
    tight (1) meaning "Follow exactly - 3-block structure, required sections"
    guided (0) meaning "Adapt thoughtfully - interface definitions within structure"
    free (-1) meaning "Principles only - teaching comments, examples"

to use this template:
    copy and adapt for new interface definitions
    replace [bracketed] placeholders with actual content
    change pragma from "template" to "interface" when complete
    remove this preamble section when adapted

    meaning "Interface is the WORD - pure declaration without implementation"
    teaching "God said, Let there be... and it was so (Genesis 1:3)"

// ───────────────────────────────────────────────────────────────────────────

core identity of this interface:

    grounded in:
        scripture "In the beginning was the Word, and the Word was with God"
            from John 1:1 in KJV
        principle "Declaration precedes implementation - the Word is first"
        anchor "All things were made by him; and without him was not any thing made"
            from John 1:3 in KJV

    serves as Word:
        role "[What this interface declares/defines]"
        paradigm "CPI-SI framework - Interface as Word"

    authored by:
        architect "[Who designed the interface contract]"
        implementation "[Who defined the declarations]"
        created [YYYY-MM-DD]
        version [MAJOR.MINOR.PATCH]
        modified [YYYY-MM-DD] for "[what changed]"

    exists to:
        purpose "[What contract does this interface establish?]"
        design "[What pattern does this interface define?]"
        philosophy "Pure declaration - WHAT without HOW"
        features:
            "[Type 1 - what it defines]"
            "[Contract 1 - what it promises]"
            "[Constraint 1 - what it enforces]"

interface of this interface:

    depends on:
        requires (1) "[interface]" for "[type dependency]"
        includes (0) "[interface]" for "[optional extension]"
        excludes (-1) "[interface]" because "[conflict reason]"
        used by "[Code that implements this interface]"
        integrates with "[Other interfaces this relates to]"

    integrated as:
        implemented by "[code modules that fulfill this contract]"
        verified through "[how compliance is checked]"
        exits valid (1) for "implementation satisfies contract"
        exits partial (0) for "implementation missing optional"
        exits invalid (-1) for "implementation violates contract"

operational context of this interface:

    blocking:
        no (-1) because "interfaces are declarations, not executions"

    health:
        system Base100 with scale from -100 to +100
        granted (1) above +50 meaning "interface well-defined"
        deferred (0) within ±50 meaning "interface needs refinement"
        denied (-1) below -50 meaning "interface broken/inconsistent"

        operations:
            "type completeness" scores +20 (1) for "all types defined"
            "contract clarity" scores +15 (1) for "contracts unambiguous"
            "constraint validity" scores +15 (1) for "constraints enforceable"
            "missing definition" scores -20 (-1) for "incomplete declaration"

// ═══════════════════════════════════════════════════════════════════════════
// END METADATA
// ═══════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════
// CONTENT
// ═══════════════════════════════════════════════════════════════════════════
//
// 3-Block Interface: METADATA → CONTENT → CLOSING
// The middle block declares WHAT without HOW - pure interface definition.
//
// 2 Tiers, 2 Sections:
//   Tier 1 - DEFINES: What this interface establishes (types, contracts, constraints)
//   Tier 2 - EXPOSES: What implementers must provide (requirements)
//
// ═══════════════════════════════════════════════════════════════════════════

declaration of this interface:

    defines:
        types (1):
            /// [TypeName] - [Brief description]
            ///
            /// teaching: [Pattern this type demonstrates]
            ///
            "[TypeName]" as "[What this type represents]"
                containing:
                    [field1] be [type]
                        meaning "[Purpose of this field]"
                    [field2] be [type]
                        meaning "[Purpose of this field]"
                        cautioning "[Constraints on this field]"

            /// [SecondTypeName] - [Brief description]
            "[SecondTypeName]" as "[What this type represents]"
                containing:
                    [field1] be [type]
                    [field2] be [type] or none

        contracts (0):
            /// [MethodName] - What implementations must provide
            ///
            /// takes: [param] - [description]
            /// returns: [type] - [description]
            ///
            /// teaching: [Pattern this contract demonstrates]
            /// cautioning: [Constraints implementations must follow]
            ///
            "[MethodName]" that takes [params] and returns [type]
                meaning "[What this method does]"
                cautioning "[What implementations must guarantee]"

            "[SecondMethodName]" that takes [params] and returns [type] or covenant
                meaning "[What this method does]"
                teaching "Covenant returns signal success states"

        constraints (-1):
            /// [InvariantName] - Rule implementations must enforce
            "[InvariantName]" ensuring "[condition that must always be true]"
                because "[why this invariant matters]"

            "[SecondInvariant]" ensuring "[condition]"
                because "[rationale]"

    exposes:
        required (1):
            /// Capabilities that implementers MUST provide
            "[capability1]" meaning "[what implementations must guarantee]"
            "[capability2]" meaning "[what implementations must guarantee]"

        optional (0):
            /// Capabilities that implementers MAY provide
            "[optional_capability]" meaning "[enhancement implementations can add]"

        forbidden (-1):
            /// Behaviors that implementations MUST NOT exhibit
            "[forbidden_behavior]" because "[why this violates the contract]"

// ═══════════════════════════════════════════════════════════════════════════
// END CONTENT
// ═══════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════
// CLOSING
// ═══════════════════════════════════════════════════════════════════════════
//
// 3-Block Interface: METADATA → CONTENT → CLOSING
// The closing block defines how this interface is fulfilled and verified.
//
// 2 Tiers, 4 Sections:
//   Tier 1 - OPERATIONS (2 sections): Verification, implementation guidance
//   Tier 2 - SYNTHESIS (2 sections): Closing note, quick reference
//
// ═══════════════════════════════════════════════════════════════════════════

operations of this interface:

    verified by:
        static (1):
            "omnic check [interface].omni" producing "interface valid"
            "omnic types [interface].omni" producing "type definitions complete"

        implementation (0):
            "[implementation].omni implements [interface].omni" verified by "type checker"
            "all required contracts satisfied" verified by "compiler"

        compliance (-1):
            "constraint violations" detected by "static analysis"
            "forbidden behaviors" flagged by "linter"

    implemented through:
        /*
         * summary "Implementation guidance"
         *
         * Interfaces are implemented by code that satisfies the contract.
         * This section describes how to implement this interface.
         *
         * teaching "Interface is Word - implementation is Work that follows the Word"
         */
        to implement this interface:
            meaning "Guidance for code that fulfills this contract"

            // Step 1: Declare implementation
            "module [name] implements [interface-name]"

            // Step 2: Define all required types
            "define types matching CONTENT defines types"

            // Step 3: Implement all required contracts
            "implement all contracts from CONTENT defines contracts"

            // Step 4: Enforce all constraints
            "ensure all constraints from CONTENT defines constraints"

            // Step 5: Verify compliance
            "run omnic check to verify implementation satisfies interface"

policy of this interface:

    modification:
        safe (1):
            "Add new optional contracts"
            "Add new constraints with default compliance"
            "Extend type definitions with optional fields"

        careful (0):
            "Change required contract signatures"
            "Modify type field requirements"

        never (-1):
            "3-block structure"
            "Remove required contracts"
            "Weaken constraints"

    future:
        planned (1):
            "[Planned extension - description]"

        considered (0):
            "[Potential addition - why uncertain]"

        rejected (-1):
            "[Known limitation - why it won't change]"

synthesis of this interface:

    overview:
        see "METADATA exists to" for "purpose and philosophy"

    declaration:
        see "CONTENT declaration" for "types, contracts, and constraints"

    dependencies:
        see "METADATA interface depends on" for "related interfaces"

    closing note:
        role "Word - Declaration that code implements"
        impact "[What implementations this interface governs]"
        scripture "In the beginning was the Word"
            from John 1:1 in KJV

    quick reference:
        check "omnic check [interface].omni"
        verify "omnic verify [impl].omni implements [interface].omni"
        types "omnic types [interface].omni"

// ═══════════════════════════════════════════════════════════════════════════
// END CLOSING
// ═══════════════════════════════════════════════════════════════════════════
