#!omni template

// ═══════════════════════════════════════════════════════════════════════════
// METADATA
// ═══════════════════════════════════════════════════════════════════════════

this is a template for "OmniCode Data (3-Block Simple)":
    keyed as "B-word-omni-seed-data-3block"
    following "3-Block Data Structure"

this template classifies as:
    independent (1) when "self-contained data with no external references"
    connected (0) when "referencing other data" such as "[list them]"
    dependent (-1) when "requiring external type definitions" such as "[list them]"

this template derives from:
    original (1) when "establishing new data pattern"
    derived (0) from "B-word-omni-seed-universal"
    variant (-1) when "intentionally departing from standard"
    documented at "bereshit/word/omni/seed/"

this template strictness is:
    tight (1) meaning "Follow exactly - 3-block structure, required sections"
    guided (0) meaning "Adapt thoughtfully - data values within structure"
    free (-1) meaning "Principles only - teaching comments, examples"

to use this template:
    copy and adapt for simple data definitions (config, settings, etc.)
    replace [bracketed] placeholders with actual content
    change pragma from "template" to "data" when complete
    remove this preamble section when adapted

    meaning "Simple data - schema and values unified for straightforward cases"
    teaching "3-block for simple, 4-block for structured, 5-block for documented"

// ───────────────────────────────────────────────────────────────────────────

core identity of this data:

    grounded in:
        scripture "The heart of the prudent getteth knowledge; and the ear of the wise seeketh knowledge"
            from Proverbs 18:15 in KJV
        principle "Data is stored truth - organized knowledge serving purpose"
        anchor "Buy the truth, and sell it not; also wisdom, and instruction, and understanding"
            from Proverbs 23:23 in KJV

    serves as Data:
        role "[What this data represents/stores]"
        paradigm "CPI-SI framework - Data as stored truth"

    authored by:
        architect "[Who designed the data structure]"
        implementation "[Who defined the values]"
        created [YYYY-MM-DD]
        version [MAJOR.MINOR.PATCH]
        modified [YYYY-MM-DD] for "[what changed]"

    exists to:
        purpose "[What purpose does this data serve?]"
        design "[Data pattern - configuration, settings, constants, etc.]"
        philosophy "Simple data - unified schema and values"
        features:
            "[What information it stores]"
            "[How it's used]"
            "[What depends on it]"

interface of this data:

    depends on:
        requires (1) "[data]" for "[type reference]"
        includes (0) "[data]" for "[optional reference]"
        excludes (-1) "[data]" because "[conflict reason]"
        used by "[What code/data consumes this]"
        integrates with "[Related data files]"

    integrated as:
        accessed "import [data-name]" for "reading this data"
        accessed "[data-name].[field]" for "field access"
        exits valid (1) for "data well-formed"
        exits partial (0) for "data incomplete"
        exits invalid (-1) for "data corrupted or missing"

operational context of this data:

    blocking:
        no (-1) because "data is declarative, not executable"
        mitigation "validate data schema before use"

    health:
        system Base100 with scale from -100 to +100
        granted (1) above +50 meaning "data valid and complete"
        deferred (0) within ±50 meaning "data needs attention"
        denied (-1) below -50 meaning "data invalid or corrupted"

        operations:
            "schema validity" scores +20 (1) for "all fields well-typed"
            "value completeness" scores +15 (1) for "all required values present"
            "reference integrity" scores +15 (1) for "all references resolve"
            "missing value" scores -20 (-1) for "required field empty"
            "type mismatch" scores -25 (-1) for "value doesn't match schema"

        cascade multipliers:
            "consumer count" multiplies by 1.5 because "invalid data affects all consumers"

// ═══════════════════════════════════════════════════════════════════════════
// END METADATA
// ═══════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════
// CONTENT
// ═══════════════════════════════════════════════════════════════════════════
//
// 3-Block Data: METADATA → CONTENT → CLOSING
// The middle block merges schema and values for simple data.
//
// 2 Tiers, 2 Sections:
//   Tier 1 - SCHEMA: What fields this data has (types and structure)
//   Tier 2 - VALUES: What values those fields hold (instances)
//
// ═══════════════════════════════════════════════════════════════════════════

definition of this data:

    schema:
        fields (1):
            /// [FieldName] - [Brief description]
            ///
            /// teaching: [Pattern this field demonstrates]
            ///
            "[field_name]" be [type]
                meaning "[Purpose of this field]"
                defaulting to [default_value]

            "[field_name_2]" be [type]
                meaning "[Purpose of this field]"
                cautioning "[Constraints on this field]"

            "[optional_field]" be [type] or none
                meaning "[Purpose when present]"

        constraints (0):
            /// [ConstraintName] - Rule this data must follow
            "[constraint_name]" ensuring "[condition that must be true]"
                because "[why this constraint matters]"

        reserved (-1):
            [none - all fields defined]

    values:
        primary (1):
            /// Primary data instance
            ///
            /// teaching: Values fulfill the schema - the actual stored truth
            ///
            "[field_name]" is [actual_value]
            "[field_name_2]" is [actual_value]

        derived (0):
            /// Computed or derived values
            "[computed_field]" is computed from "[source fields]"
                meaning "[How derivation works]"

        reserved (-1):
            [none - all values assigned]

// ═══════════════════════════════════════════════════════════════════════════
// END CONTENT
// ═══════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════
// CLOSING
// ═══════════════════════════════════════════════════════════════════════════
//
// 3-Block Data: METADATA → CONTENT → CLOSING
// The closing block defines validation, usage, and synthesis.
//
// 2 Tiers, 4 Sections:
//   Tier 1 - OPERATIONS (2 sections): Validation, access patterns
//   Tier 2 - SYNTHESIS (2 sections): Closing note, quick reference
//
// ═══════════════════════════════════════════════════════════════════════════

operations of this data:

    verified by:
        static (1):
            "omnic check [data].omni" producing "data valid"
            "omnic schema [data].omni" producing "schema well-formed"

        runtime (0):
            "import [data]" succeeding when "data file exists"
            "[data].[field]" returning when "field defined"

        integrity (-1):
            "missing required field" detected by "schema validator"
            "type mismatch" flagged by "type checker"

    accessed through:
        /*
         * summary "Access patterns for this data"
         *
         * Data is read-only after definition. Access is through import
         * and field reference. Changes require new version.
         *
         * teaching "Data as stored truth - immutable once defined"
         */
        to access this data:
            meaning "How code reads this data"

            // Step 1: Import the data file
            "import [data-name] from [path]"

            // Step 2: Reference fields
            "[data-name].[field_name]" returns "[type]"

            // Step 3: Use in expressions
            "when [data-name].[field] is [value]"

policy of this data:

    modification:
        safe (1):
            "Add new optional fields with defaults"
            "Update values within type constraints"
            "Add new derived values"

        careful (0):
            "Change field types"
            "Modify constraints"

        never (-1):
            "3-block structure"
            "Remove required fields"
            "Break type contracts"

    future:
        planned (1):
            "[Planned field addition - description]"

        considered (0):
            "[Potential change - why uncertain]"

        rejected (-1):
            "[Known limitation - why it won't change]"

synthesis of this data:

    overview:
        see "METADATA exists to" for "purpose and philosophy"

    schema:
        see "CONTENT definition schema" for "field definitions"

    values:
        see "CONTENT definition values" for "actual data"

    dependencies:
        see "METADATA interface depends on" for "related data"

    closing note:
        role "Data - Stored truth serving system needs"
        impact "[What code/systems depend on this data]"
        scripture "The heart of the prudent getteth knowledge"
            from Proverbs 18:15 in KJV

    quick reference:
        check "omnic check [data].omni"
        import "import [data-name] from [path]"
        access "[data-name].[field]"

// ═══════════════════════════════════════════════════════════════════════════
// END CLOSING
// ═══════════════════════════════════════════════════════════════════════════
