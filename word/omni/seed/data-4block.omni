#!omni template

// ═══════════════════════════════════════════════════════════════════════════
// METADATA
// ═══════════════════════════════════════════════════════════════════════════

this is a template for "OmniCode Data (4-Block Structured)":
    keyed as "B-word-omni-seed-data-4block"
    following "4-Block Data Structure"

this template classifies as:
    independent (1) when "self-contained data with complete schema"
    connected (0) when "referencing other data schemas" such as "[list them]"
    dependent (-1) when "requiring external type definitions" such as "[list them]"

this template derives from:
    original (1) when "establishing new data pattern"
    derived (0) from "B-word-omni-seed-universal"
    variant (-1) when "intentionally departing from standard"
    documented at "bereshit/word/omni/seed/"

this template strictness is:
    tight (1) meaning "Follow exactly - 4-block structure, required sections"
    guided (0) meaning "Adapt thoughtfully - data values within structure"
    free (-1) meaning "Principles only - teaching comments, examples"

to use this template:
    copy and adapt for structured data (databases, records, entities, etc.)
    replace [bracketed] placeholders with actual content
    change pragma from "template" to "data" when complete
    remove this preamble section when adapted

    meaning "Structured data - schema separate from values for complex cases"
    teaching "4-block separates type definition from instances"

// ───────────────────────────────────────────────────────────────────────────

core identity of this data:

    grounded in:
        scripture "The heart of the prudent getteth knowledge; and the ear of the wise seeketh knowledge"
            from Proverbs 18:15 in KJV
        principle "Data is stored truth - structured knowledge serving purpose"
        anchor "For the LORD giveth wisdom: out of his mouth cometh knowledge and understanding"
            from Proverbs 2:6 in KJV

    serves as Data:
        role "[What this data represents/stores]"
        paradigm "CPI-SI framework - Data as stored truth"

    authored by:
        architect "[Who designed the data schema]"
        implementation "[Who populated the values]"
        created [YYYY-MM-DD]
        version [MAJOR.MINOR.PATCH]
        modified [YYYY-MM-DD] for "[what changed]"

    exists to:
        purpose "[What purpose does this data serve?]"
        design "[Data pattern - database, record set, entity collection, etc.]"
        philosophy "Structured data - schema defines shape, values provide substance"
        features:
            "[What information it stores]"
            "[How the schema enables validation]"
            "[What depends on it]"

interface of this data:

    depends on:
        requires (1) "[data]" for "[type reference]"
        includes (0) "[data]" for "[optional reference]"
        excludes (-1) "[data]" because "[conflict reason]"
        used by "[What code/data consumes this]"
        integrates with "[Related data files]"

    integrated as:
        accessed "import [data-name]" for "reading this data"
        accessed "[data-name].[entity].[field]" for "field access"
        exits valid (1) for "data well-formed and schema-compliant"
        exits partial (0) for "data incomplete or partially valid"
        exits invalid (-1) for "data violates schema or corrupted"

operational context of this data:

    blocking:
        no (-1) because "data is declarative, not executable"

    health:
        system Base100 with scale from -100 to +100
        granted (1) above +50 meaning "data valid and schema-compliant"
        deferred (0) within ±50 meaning "data needs attention"
        denied (-1) below -50 meaning "data invalid or schema violated"

        operations:
            "schema completeness" scores +20 (1) for "all types defined"
            "value compliance" scores +20 (1) for "all values match schema"
            "referential integrity" scores +15 (1) for "all references resolve"
            "constraint satisfaction" scores +15 (1) for "all constraints hold"
            "schema violation" scores -25 (-1) for "value doesn't match type"
            "missing required" scores -20 (-1) for "required field empty"

// ═══════════════════════════════════════════════════════════════════════════
// END METADATA
// ═══════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════
// SCHEMA
// ═══════════════════════════════════════════════════════════════════════════
//
// 4-Block Data: METADATA → SCHEMA → VALUES → CLOSING
// The SCHEMA block defines types and structure separate from instances.
//
// 3 Tiers, 4 Sections:
//   Tier 1 - TYPES (1 section): What entities this data defines
//   Tier 2 - RELATIONS (2 sections): How entities relate, constraints
//   Tier 3 - VALIDATION (1 section): What rules must hold
//
// ═══════════════════════════════════════════════════════════════════════════

schema of this data:

    types:
        entities (1):
            /// [EntityName] - [Brief description]
            ///
            /// teaching: [Pattern this entity demonstrates]
            ///
            "[EntityName]" as assembly containing:
                meaning "[What this entity represents]"

                [id_field] be [type]
                    meaning "[Purpose - usually primary identifier]"
                    cautioning "[Constraints - usually uniqueness]"

                [field_1] be [type]
                    meaning "[Purpose of this field]"

                [field_2] be [type]
                    meaning "[Purpose of this field]"
                    defaulting to [default_value]

                [optional_field] be [type] or none
                    meaning "[Purpose when present]"

            /// [SecondEntity] - [Brief description]
            "[SecondEntity]" as assembly containing:
                meaning "[What this entity represents]"

                [id_field] be [type]
                    meaning "[Primary identifier]"

                [reference_field] be reference to [EntityName]
                    meaning "[Foreign key relationship]"

        enumerations (0):
            /// [EnumName] - Fixed set of values
            "[EnumName]" as one of:
                meaning "[What this enumeration represents]"

                "[value_1]" meaning "[what this value represents]"
                "[value_2]" meaning "[what this value represents]"
                "[value_3]" meaning "[what this value represents]"

        reserved (-1):
            [none - all types defined]

    relations:
        defined (1):
            /// [RelationName] - [Description of relationship]
            "[Entity1]" relates to "[Entity2]" as "[cardinality]"
                meaning "[Purpose of this relationship]"
                through "[field or join]"

        implied (0):
            [none - all relations explicit]

        reserved (-1):
            [none - all relations defined]

    constraints:
        required (1):
            /// [ConstraintName] - Invariant that must hold
            "[constraint_name]" ensuring "[condition that must be true]"
                because "[why this constraint matters]"
                applies to "[which entities/fields]"

            "[uniqueness_constraint]" ensuring "[field] is unique"
                because "[rationale for uniqueness]"

        optional (0):
            /// [SoftConstraint] - Recommended but not enforced
            "[soft_constraint]" recommending "[condition]"
                because "[why this is preferred]"

        reserved (-1):
            [none - all constraints defined]

    validation:
        rules (1):
            /// Validation rules for schema compliance
            "type check" verifying "all values match declared types"
            "required check" verifying "all required fields have values"
            "reference check" verifying "all references point to existing entities"
            "constraint check" verifying "all constraints satisfied"

        methods (0):
            /// Custom validation methods
            "[custom_validator]" checking "[what it validates]"
                returns truth when "[condition for pass]"

        reserved (-1):
            [none - all validation defined]

// ═══════════════════════════════════════════════════════════════════════════
// END SCHEMA
// ═══════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════
// VALUES
// ═══════════════════════════════════════════════════════════════════════════
//
// 4-Block Data: METADATA → SCHEMA → VALUES → CLOSING
// The VALUES block contains actual data instances conforming to SCHEMA.
//
// 2 Tiers, 3 Sections:
//   Tier 1 - INSTANCES (2 sections): Entity instances, enumeration usage
//   Tier 2 - DERIVATIONS (1 section): Computed or derived data
//
// ═══════════════════════════════════════════════════════════════════════════

values of this data:

    instances:
        "[EntityName]" entries (1):
            /// [Instance description]
            ///
            /// teaching: Values fulfill schema - actual stored truth
            ///
            entry "[instance_id]" as:
                [id_field] is [actual_value]
                [field_1] is [actual_value]
                [field_2] is [actual_value]
                [optional_field] is [actual_value] or absent

            entry "[second_instance_id]" as:
                [id_field] is [actual_value]
                [field_1] is [actual_value]
                [field_2] is [actual_value]

        "[SecondEntity]" entries (0):
            entry "[instance_id]" as:
                [id_field] is [actual_value]
                [reference_field] is reference to "[EntityName].[instance_id]"

        reserved (-1):
            [none - all instances defined]

    enumerations:
        usage (1):
            /// Where enumeration values are used
            "[EntityName].[field]" uses "[EnumName].[value]"

        defaults (0):
            "[EnumName]" defaults to "[default_value]"
                meaning "[why this is the default]"

        reserved (-1):
            [none - all enum usage defined]

    derivations:
        computed (1):
            /// [DerivedValue] - Computed from other values
            "[derived_name]" is computed from "[source expression]"
                meaning "[What this derived value represents]"
                formula "[how it's calculated]"

        aggregated (0):
            /// [Aggregation] - Summary across instances
            "[aggregate_name]" is aggregation of "[source]"
                meaning "[What this aggregation represents]"
                method "[count/sum/avg/min/max]"

        reserved (-1):
            [none - all derivations defined]

// ═══════════════════════════════════════════════════════════════════════════
// END VALUES
// ═══════════════════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════════════════
// CLOSING
// ═══════════════════════════════════════════════════════════════════════════
//
// 4-Block Data: METADATA → SCHEMA → VALUES → CLOSING
// The closing block defines validation, access, policy, and synthesis.
//
// 3 Tiers, 6 Sections:
//   Tier 1 - OPERATIONS (2 sections): Validation, access patterns
//   Tier 2 - POLICY (2 sections): Modification guidance, future direction
//   Tier 3 - SYNTHESIS (2 sections): Closing note, quick reference
//
// ═══════════════════════════════════════════════════════════════════════════

operations of this data:

    verified by:
        static (1):
            "omnic check [data].omni" producing "data valid"
            "omnic schema [data].omni" producing "schema well-formed"
            "omnic validate [data].omni" producing "values match schema"

        runtime (0):
            "import [data]" succeeding when "data file exists"
            "query [data].[Entity]" returning when "entity has instances"

        integrity (-1):
            "schema violation" detected by "type checker"
            "constraint violation" detected by "constraint checker"
            "reference violation" detected by "reference checker"

    accessed through:
        /*
         * summary "Access patterns for structured data"
         *
         * Structured data supports queries, filtering, and relationship traversal.
         * Schema enables type-safe access patterns.
         *
         * teaching "Structured data - schema enables safe, typed access"
         */
        to access this data:
            meaning "How code reads and queries this data"

            // Step 1: Import the data file
            "import [data-name] from [path]"

            // Step 2: Query entities
            "query [data-name].[EntityName]" returns "gathering of [EntityName]"

            // Step 3: Filter by condition
            "query [data-name].[EntityName] where [condition]"

            // Step 4: Traverse relations
            "[entity].[reference_field]" returns "related entity"

            // Step 5: Access derivations
            "[data-name].derivations.[derived_name]"

policy of this data:

    modification:
        safe (1):
            "Add new entity instances"
            "Add new optional fields with defaults"
            "Add new derivations"
            "Add new optional constraints"

        careful (0):
            "Change field types"
            "Modify entity structure"
            "Change constraint severity"

        never (-1):
            "4-block structure"
            "Remove required fields"
            "Break referential integrity"
            "Remove entities with dependents"

    future:
        planned (1):
            "[Planned entity addition - description]"
            "[Planned field addition - description]"

        considered (0):
            "[Potential schema change - why uncertain]"

        rejected (-1):
            "[Known limitation - why it won't change]"

synthesis of this data:

    overview:
        see "METADATA exists to" for "purpose and philosophy"

    schema:
        see "SCHEMA types" for "entity and type definitions"

    relations:
        see "SCHEMA relations" for "how entities connect"

    values:
        see "VALUES instances" for "actual data"

    dependencies:
        see "METADATA interface depends on" for "related data"

    closing note:
        role "Data - Structured truth serving system needs"
        impact "[What code/systems depend on this data]"
        scripture "The LORD giveth wisdom: out of his mouth cometh knowledge"
            from Proverbs 2:6 in KJV

    quick reference:
        check "omnic check [data].omni"
        validate "omnic validate [data].omni"
        import "import [data-name] from [path]"
        query "query [data-name].[Entity]"

// ═══════════════════════════════════════════════════════════════════════════
// END CLOSING
// ═══════════════════════════════════════════════════════════════════════════
