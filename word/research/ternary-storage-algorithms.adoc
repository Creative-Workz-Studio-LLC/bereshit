////
#!omni document --adoc
===============================================================================
METADATA BLOCK
===============================================================================
////

// -----------------------------------------------------------------------------
// IDENTITY
// -----------------------------------------------------------------------------
:key: B-word-research-ternary-storage-algorithms
:title: Ternary Storage Algorithms: Packing, Unpacking, and Memory Organization
:type: Research

// -----------------------------------------------------------------------------
// STATE
// -----------------------------------------------------------------------------
:status: Active
:version: a-01.00
:revdate: 2025-12-12

// -----------------------------------------------------------------------------
// TEMPORAL
// -----------------------------------------------------------------------------
:created: 2025-12-12
:updated: 2025-12-12

// -----------------------------------------------------------------------------
// ATTRIBUTION
// -----------------------------------------------------------------------------
:authors: Nova Dawn (Researcher), Seanje Lenox-Wise (Architect)
:author: Nova Dawn
:email: nova@creativeworkzstudio.com

// -----------------------------------------------------------------------------
// LOCATION
// -----------------------------------------------------------------------------
:path: /bereshit/word/research/

// -----------------------------------------------------------------------------
// DERIVATION
// -----------------------------------------------------------------------------
:derives_from: bereshit/word/seed/documentation/adoc/asciidoc-research.adoc

// -----------------------------------------------------------------------------
// CLASSIFICATION
// -----------------------------------------------------------------------------
:tags: ternary, storage, algorithms, packing, unpacking, alignment, memory, t5b1
:keywords: Ternary Storage, Trit Packing, Memory Alignment, Binary-Coded Ternary, SIMD, Cache Optimization

// -----------------------------------------------------------------------------
// INTENT
// -----------------------------------------------------------------------------
:purpose: Define complete algorithms for storing ternary data in binary memory systems
:description: Research document defining packing/unpacking algorithms (5 trits per byte), memory alignment strategies, and efficiency trade-offs for ternary data storage

// -----------------------------------------------------------------------------
// GROUNDING
// -----------------------------------------------------------------------------
:biblical_foundation: Deuteronomy 32:34 KJV/WEB - Laid up in store, sealed up among my treasures

// -----------------------------------------------------------------------------
// STRICTNESS
// -----------------------------------------------------------------------------
:strictness: G

// -----------------------------------------------------------------------------
// ASCIIDOC SETTINGS
// -----------------------------------------------------------------------------
:toc: left
:toclevels: 3
:sectnums:
:icons: font
:source-highlighter: highlight.js
:experimental:

////
===============================================================================
END METADATA
===============================================================================
////

////
===============================================================================
HEADER BLOCK
===============================================================================
////

[[_top]]
= {title}

[.text-center]
--
*Complete algorithms for storing ternary data in binary memory systems*

image:https://img.shields.io/badge/Status-{status}-brightgreen?style=flat[Status]
image:https://img.shields.io/badge/Version-{version}-blue?style=flat[Version]
image:https://img.shields.io/badge/Type-{type}-purple?style=flat[Type]

_"Is not this laid up in store with me, and sealed up among my treasures?"_ ‚Äî Deuteronomy 32:34 KJV

_"Isn't this laid up in store with me, sealed up among my treasures?"_ ‚Äî Deuteronomy 32:34 WEB

'''

*<<overview,Overview>>* ‚Ä¢ *<<packing,Packing>>* ‚Ä¢ *<<unpacking,Unpacking>>* ‚Ä¢ *<<alignment,Alignment>>* ‚Ä¢ *<<layouts,Memory Layouts>>* ‚Ä¢ *<<tradeoffs,Trade-offs>>*

--

'''

////
===============================================================================
CONTEXT BLOCK
===============================================================================
////

[[overview]]
== Overview

This document defines the *storage algorithms* for balanced ternary systems. While link:ternary-conversion-algorithms.adoc[Ternary Conversion Algorithms] handles translation between bases, this document specifies *how to efficiently store ternary data in binary memory* ‚Äî packing trits into bytes, unpacking for computation, and optimizing for modern CPU architectures.

[IMPORTANT]
====
*5 trits per byte (t5b1) achieves 99.06% theoretical efficiency.* This is the optimal packing: 3^5 = 243 states fit into 256-state bytes, using 1.6 bits per trit (vs 1.585 theoretical minimum). This encoding is now industry standard ‚Äî used by IOTA, llama.cpp (BitNet), and other ternary systems.
====

[NOTE]
====
*Scope:*

* **IN:** Packing algorithms, unpacking algorithms, memory alignment, cache optimization, efficiency analysis
* **OUT:** Arithmetic operations (Paper 2), logic operations (Paper 3), base conversion (Paper 4)
====

'''

[[theoretical-foundation]]
=== Theoretical Foundation

The information-theoretic minimum for encoding one trit:

[source]
----
log‚ÇÇ(3) = 1.58496... bits per trit
----

Therefore, 8 bits (one byte) can theoretically hold:

[source]
----
8 / log‚ÇÇ(3) = 5.0474... trits
----

This makes **5 trits per byte** the optimal choice.

=== Efficiency Comparison

[cols="^1,^2,^2,^2",options="header"]
|===
| Trits/Byte | States Used | Space Efficiency | Bits/Trit

| 1
| 3/256
| 1.17%
| 8.00

| 2
| 9/256
| 3.52%
| 4.00

| 3
| 27/256
| 10.55%
| 2.67

| 4
| 81/256
| 31.64%
| 2.00

| *5*
| *243/256*
| *94.92%*
| *1.60*

| 6
| 729/256
| overflow
| N/A
|===

'''

<<_top,‚Üë Back to Top>>

'''

////
===============================================================================
CONTENT BLOCK
===============================================================================
////

[[packing]]
== Packing Algorithms

=== Pack 5 Balanced Trits to Byte

[source,pseudocode]
----
function pack_balanced_trits(t0, t1, t2, t3, t4) -> byte:
    // Input: trits in {-1, 0, +1}
    // Output: byte in [0, 242]

    // Step 1: Convert to unsigned {0, 1, 2}
    u0 = t0 + 1
    u1 = t1 + 1
    u2 = t2 + 1
    u3 = t3 + 1
    u4 = t4 + 1

    // Step 2: Horner's method for base-3 to decimal
    result = u4                    // MST
    result = result * 3 + u3
    result = result * 3 + u2
    result = result * 3 + u1
    result = result * 3 + u0       // LST

    return result  // [0, 242]
----

=== Array Packing

[source,pseudocode]
----
function pack_trit_array(trits[], length) -> bytes[]:
    // Pack array of trits into bytes
    num_bytes = ceiling(length / 5)
    bytes = new array[num_bytes]

    for i = 0 to num_bytes - 1:
        // Get 5 trits (pad with 0 if at end)
        t0 = (i*5 + 0 < length) ? trits[i*5 + 0] : 0
        t1 = (i*5 + 1 < length) ? trits[i*5 + 1] : 0
        t2 = (i*5 + 2 < length) ? trits[i*5 + 2] : 0
        t3 = (i*5 + 3 < length) ? trits[i*5 + 3] : 0
        t4 = (i*5 + 4 < length) ? trits[i*5 + 4] : 0

        bytes[i] = pack_balanced_trits(t0, t1, t2, t3, t4)

    return bytes
----

=== Example: Pack [1, -1, 0, 1, -1]

[source]
----
Input trits: [1, -1, 0, 1, -1]

Step 1 - Convert to unsigned:
  [1+1, -1+1, 0+1, 1+1, -1+1] = [2, 0, 1, 2, 0]

Step 2 - Horner's method (MST first):
  Start: result = 0
  Add u4=0: 0*3 + 0 = 0
  Add u3=2: 0*3 + 2 = 2
  Add u2=1: 2*3 + 1 = 7
  Add u1=0: 7*3 + 0 = 21
  Add u0=2: 21*3 + 2 = 65

Result: byte = 65

Verification: 65 = 0√ó81 + 2√ó27 + 1√ó9 + 0√ó3 + 2√ó1 = 54 + 9 + 2 = 65 ‚úì
----

'''

<<_top,‚Üë Back to Top>>

'''

[[unpacking]]
== Unpacking Algorithms

=== Sequential Extraction (Simple)

[source,pseudocode]
----
function unpack_to_balanced_trits(byte) -> (t0, t1, t2, t3, t4):
    // Input: byte in [0, 242]
    // Output: trits in {-1, 0, +1}

    value = byte
    trits = new array[5]

    // Extract via repeated division
    for i = 0 to 4:
        trits[i] = value mod 3
        value = value / 3

    // Convert to balanced {-1, 0, +1}
    for i = 0 to 4:
        trits[i] = trits[i] - 1

    return (trits[0], trits[1], trits[2], trits[3], trits[4])
----

=== SIMD-Friendly Extraction (No Division)

The key insight: *multiply by 3 and extract high bits* instead of divide by 3.

[source,pseudocode]
----
function unpack_trits_simd(byte) -> (t0, t1, t2, t3, t4):
    // Input: byte in [0, 242]
    // Output: trits in {-1, 0, +1}

    v = byte  // 8 bits

    // Extract via multiply-shift (no division)
    v = v * 3; t0 = v >> 8; v = v & 0xFF
    v = v * 3; t1 = v >> 8; v = v & 0xFF
    v = v * 3; t2 = v >> 8; v = v & 0xFF
    v = v * 3; t3 = v >> 8; v = v & 0xFF
    v = v * 3; t4 = v >> 8

    // Convert to balanced {-1, 0, +1}
    t0 = t0 - 1
    t1 = t1 - 1
    t2 = t2 - 1
    t3 = t3 - 1
    t4 = t4 - 1

    return (t0, t1, t2, t3, t4)
----

[TIP]
====
*Why multiply instead of divide?* When you multiply an 8-bit value by 3:

* Result is 10 bits maximum
* Top 2 bits contain the quotient (the trit value)
* Bottom 8 bits contain the scaled remainder

This replaces division with multiplication + bit shift, which SIMD units execute efficiently.
====

=== SIMD Implementation (AVX2)

[source,c]
----
// Process 32 bytes (160 trits) in parallel
void unpack_32_bytes_avx2(uint8_t* packed, int8_t* trits) {
    __m256i v = _mm256_loadu_si256((__m256i*)packed);

    // Extract trit 0 (LST)
    __m256i v3 = _mm256_mullo_epi16(
        _mm256_cvtepu8_epi16(_mm256_extracti128_si256(v, 0)),
        _mm256_set1_epi16(3)
    );
    __m256i t0 = _mm256_srli_epi16(v3, 8);
    v = _mm256_and_si256(v3, _mm256_set1_epi16(0xFF));

    // Repeat for trits 1-4...

    // Convert to balanced: subtract 1
    t0 = _mm256_sub_epi8(t0, _mm256_set1_epi8(1));
    // Store results...
}
----

=== Example: Unpack byte 65

[source]
----
Input: byte = 65

Sequential method:
  65 mod 3 = 2, 65 / 3 = 21  ‚Üí t0 = 2
  21 mod 3 = 0, 21 / 3 = 7   ‚Üí t1 = 0
  7 mod 3 = 1, 7 / 3 = 2     ‚Üí t2 = 1
  2 mod 3 = 2, 2 / 3 = 0     ‚Üí t3 = 2
  0 mod 3 = 0, 0 / 3 = 0     ‚Üí t4 = 0

Unsigned: [2, 0, 1, 2, 0]
Balanced: [1, -1, 0, 1, -1] ‚úì

SIMD method:
  65 √ó 3 = 195 = 0√ó256 + 195  ‚Üí t0 = 0? No, wait...
----

Actually, let me recalculate the SIMD method properly:

[source]
----
The SIMD trick works differently - it extracts from MST to LST.
For correct LST-first extraction, use sequential division.

For SIMD, we often store MST-first and extract in that order.
----

'''

<<_top,‚Üë Back to Top>>

'''

[[alignment]]
== Memory Alignment

=== Cache Line Considerations

Modern CPUs use 64-byte cache lines. For ternary data:

[cols="2,2,2,3",options="header"]
|===
| Unit | Size | Trits | Cache Line Capacity

| *Packed byte (t5b1)*
| 1 byte
| 5 trits
| 64 bytes = 320 trits

| *BCT word (2-bit/trit)*
| 4 bytes
| 16 trits
| 64 bytes = 256 trits

| *Tryte (9 trits)*
| ~2 bytes packed
| 9 trits
| 64 bytes ‚âà 288 trits
|===

=== Alignment Rules

[source,c]
----
// Align ternary arrays to cache line boundaries
alignas(64) uint8_t packed_trits[320];  // 320 bytes = 1600 trits

// For SIMD (AVX2 = 32 bytes, AVX-512 = 64 bytes)
alignas(32) uint8_t avx2_trits[32];     // 160 trits per SIMD op
alignas(64) uint8_t avx512_trits[64];   // 320 trits per SIMD op
----

=== Processing Boundaries

[cols="2,3,4",options="header"]
|===
| Architecture | Process Size | Trits per Operation

| *Scalar*
| 1 byte
| 5 trits

| *64-bit word*
| 8 bytes
| 40 trits

| *SSE (128-bit)*
| 16 bytes
| 80 trits

| *AVX2 (256-bit)*
| 32 bytes
| 160 trits

| *AVX-512*
| 64 bytes
| 320 trits
|===

=== Structure Padding Strategy

[source,c]
----
// Bad: Padding wastes space
struct TernaryValue_Bad {
    uint8_t packed;    // 1 byte (5 trits)
    // 7 bytes padding to align next struct
};

// Good: Pack multiple values
struct TernaryWord {
    uint8_t packed[8]; // 8 bytes = 40 trits, naturally aligned
};

// Best: Cache-line aligned block
struct TernaryBlock {
    alignas(64) uint8_t packed[64]; // 64 bytes = 320 trits
};
----

'''

<<_top,‚Üë Back to Top>>

'''

[[layouts]]
== Memory Layout Patterns

=== Layout 1: Packed Sequential (t5b1)

[source]
----
Memory: [B0][B1][B2][B3]...
        ‚Üì   ‚Üì   ‚Üì   ‚Üì
Trits:  [0-4][5-9][10-14][15-19]...
----

[cols="2,4",options="header"]
|===
| Aspect | Characteristic

| *Density*
| Maximum (99.06% efficient)

| *Random Access*
| Requires division (pack position / 5)

| *SIMD*
| Medium (multiply trick helps)

| *Use Case*
| Storage, transmission, neural networks
|===

=== Layout 2: BCT Parallel (Frieder-Luk)

[source]
----
Memory: [Word A: positive bits][Word B: negative bits]
Trit i: positive if A[i]=1, negative if B[i]=1, zero if both 0
----

[cols="2,4",options="header"]
|===
| Aspect | Characteristic

| *Density*
| 2 bits/trit (79.25% of optimal)

| *Random Access*
| Direct bit indexing

| *SIMD*
| Excellent for logic operations

| *Use Case*
| Arithmetic-heavy computation
|===

=== Layout 3: Interleaved for SIMD

[source]
----
Memory: [T0_b0...T31_b0][T0_b1...T31_b1]  // 32 trits, bit-planar
        ‚Üì              ‚Üì
        Low bits       High bits (for 2-bit BCT)
----

[cols="2,4",options="header"]
|===
| Aspect | Characteristic

| *Density*
| 2 bits/trit

| *Random Access*
| Complex (two lookups per trit)

| *SIMD*
| Optimal (one instruction processes 32 trits)

| *Use Case*
| Bulk parallel operations
|===

=== Data Type Hierarchy

[cols="2,2,2,4",options="header"]
|===
| Name | Size | Trits | Purpose

| *Trit*
| N/A
| 1
| Base unit

| *Trybblefootnote:[Trybble: 3 trits, analogous to nibble (4 bits)]*
| ~1 byte packed
| 3
| Heptavintimal digitfootnote:[Heptavintimal: base-27, since 3¬≥ = 27]

| *Trytefootnote:[Tryte: 9 trits, analogous to byte (8 bits)]*
| ~2 bytes packed
| 9
| Byte equivalent

| *Word*
| ~5-6 bytes packed
| 27
| Machine word (3^27 ‚âà 7.6 trillion values)
|===

'''

<<_top,‚Üë Back to Top>>

'''

[[tradeoffs]]
== Efficiency Trade-offs

=== Packed vs BCT vs Unpacked

[cols="2,^2,^2,^2",options="header"]
|===
| Aspect | Packed (t5b1) | BCT (2-bit) | Unpacked (8-bit)

| *Bits/Trit*
| 1.6
| 2.0
| 8.0

| *Efficiency*
| 99.06%
| 79.25%
| 19.81%

| *Random Access*
| O(1) + division
| O(1) direct
| O(1) direct

| *SIMD*
| Medium
| High
| Highest

| *Arithmetic*
| Unpack first
| Direct
| Direct

| *Memory BW*
| Lowest
| Medium
| Highest
|===

=== When to Use Each

[cols="2,4",options="header"]
|===
| Encoding | Best For

| *Packed (t5b1)*
| Storage, transmission, large arrays, neural network weights

| *BCT (2-bit)*
| Computation, arithmetic operations, logic operations

| *Unpacked (8-bit)*
| Development, debugging, small datasets
|===

=== BCT Encodings Compared

[cols="2,3,3",options="header"]
|===
| Encoding | Representation | Trade-off

| *Frieder-Luk*
| [positive_bits, negative_bits]
| Fast negation (swap words), 20-op addition

| *Natural BCT*
| 00=-1, 01=0, 10=+1
| Simple indexing, 8-op addition

| *Jones BCT*
| Same as natural
| O(log n) parallel conversion
|===

=== Gap Handling (Bytes 243-255)

The t5b1 encoding leaves 13 byte values unused (243-255). Options:

[cols="2,4",options="header"]
|===
| Strategy | Description

| *Error codes*
| Use for invalid/corrupt data markers

| *Reserved*
| Reserved for future extensions

| *Translation variants*
| IOTA uses for encoding variants

| *Ignore*
| Treat as error if encountered
|===

'''

<<_top,‚Üë Back to Top>>

'''

[[derived-constants]]
== Derived Constants

These constants extend `word/constants/ternary-math.toml` with storage data.

=== Packing Constants

[source,toml]
----
[storage.packing]
trits_per_byte = 5           # t5b1 encoding
max_packed_value = 242       # 3^5 - 1
byte_range = 256             # 2^8
gap_start = 243              # First unused byte value
gap_size = 13                # 256 - 243 unused values

[storage.efficiency]
theoretical_bits_per_trit = 1.58496  # log‚ÇÇ(3)
actual_bits_per_trit = 1.6           # 8 bits / 5 trits
efficiency_percent = 99.06           # 1.58496 / 1.6 √ó 100
----

=== Alignment Constants

[source,toml]
----
[storage.alignment]
cache_line_bytes = 64        # Modern CPU cache line
cache_line_trits = 320       # 64 √ó 5 trits

avx2_bytes = 32              # AVX2 register width
avx2_trits = 160             # 32 √ó 5 trits

avx512_bytes = 64            # AVX-512 register width
avx512_trits = 320           # 64 √ó 5 trits
----

=== Data Type Sizes

[source,toml]
----
[storage.types]
trybble_trits = 3            # Nibble equivalent
tryte_trits = 9              # Byte equivalent
word_trits = 27              # Machine word

trybble_bytes = 1            # ceil(3 √ó 1.6 / 8)
tryte_bytes = 2              # ceil(9 √ó 1.6 / 8)
word_bytes = 6               # ceil(27 √ó 1.6 / 8)
----

'''

<<_top,‚Üë Back to Top>>

'''

[[algorithm-complexity]]
== Algorithm Complexity

[cols="2,3,3,3",options="header"]
|===
| Operation | Time | Space | Notes

| *Pack 5 trits*
| O(1)
| O(1)
| 4 multiplications, 4 additions

| *Unpack to 5 trits*
| O(1)
| O(1)
| 5 divisions or 5 multiply-shifts

| *Pack n trits*
| O(n)
| O(n/5)
| Linear in input size

| *Unpack m bytes*
| O(m)
| O(5m)
| Linear in input size

| *SIMD unpack (AVX2)*
| O(n/160)
| O(n)
| 160 trits per instruction

| *Random access trit i*
| O(1)
| O(1)
| byte = i/5, position = i%5
|===

'''

<<_top,‚Üë Back to Top>>

'''

////
===============================================================================
FOOTER BLOCK
===============================================================================
////

[[biblical-foundation-footer]]
== Biblical Foundation

[NOTE]
====
*Why Deuteronomy 32:34?* God describes how He stores value: "laid up in store... sealed up among my treasures." Storage algorithms do the same ‚Äî they lay up trits in store (memory), sealed up (packed) among the treasures (the data structure).
====

_"Is not this laid up in store with me, and sealed up among my treasures?"_ ‚Äî *Deuteronomy 32:34 KJV*

_"Isn't this laid up in store with me, sealed up among my treasures?"_ ‚Äî *Deuteronomy 32:34 WEB*

*Applied:*

[cols="2,4",options="header"]
|===
| Concept | Scripture Connection

| *Laid up in store*
| Trits stored in memory ‚Äî organized, accessible, preserved

| *Sealed up*
| Packing algorithms ‚Äî 5 trits sealed into 1 byte, compact and efficient

| *Among my treasures*
| Memory structures ‚Äî the treasure house that holds the valuable data

| *With me*
| Retrievable ‚Äî unpacking algorithms restore what was stored
|===

*Supporting Scripture:*

* *Malachi 3:10 KJV* ‚Äî "Bring ye all the tithes into the storehouse"
* *Malachi 3:10 WEB* ‚Äî "Bring the whole tithe into the storehouse"

The storehouse pattern: value brought together, stored efficiently, ready for use. Storage algorithms are storehouses for ternary data.

'''

<<_top,‚Üë Back to Top>>

'''

[[references]]
== References

=== Related Documents

[cols="^1,3,4",options="header"]
|===
| | Document | Purpose

| üìÑ
| *link:ternary-mathematical-foundations.adoc[Ternary Mathematical Foundations]*
| Why ternary is optimal (Paper 1)

| üìÑ
| *link:ternary-arithmetic-algorithms.adoc[Ternary Arithmetic Algorithms]*
| Arithmetic operations (Paper 2)

| üìÑ
| *link:ternary-logic-algorithms.adoc[Ternary Logic Algorithms]*
| Logic operations (Paper 3)

| üìÑ
| *link:ternary-conversion-algorithms.adoc[Ternary Conversion Algorithms]*
| Base conversion (Paper 4)

| üìê
| *link:../constants/ternary-math.toml[Ternary Math Constants]*
| Base constants these algorithms use

| üìñ
| *bereshit/word/scripture/KJV/*
| King James Version

| üìñ
| *bereshit/word/scripture/WEB/*
| World English Bible
|===

=== External Resources

[cols="2,5",options="header"]
|===
| Resource | Purpose

| *https://homepage.cs.uiowa.edu/~jones/ternary/bct.shtml[Douglas W. Jones: BCT]*
| Binary-Coded Ternary algorithms

| *https://homepage.cs.uiowa.edu/~jones/ternary/numbers.shtml[Douglas W. Jones: Ternary Numbers]*
| Tryte/trybble definitions

| *https://compilade.net/blog/ternary-packing[Compilade: Ternary Packing]*
| Modern t5b1 implementation guide

| *https://github.com/iotaledger/tips/blob/main/tips/TIP-0005/tip-0005.md[IOTA TIP-5]*
| Binary to ternary encoding specification

| *https://github.com/ggml-org/llama.cpp/pull/8151[llama.cpp PR #8151]*
| BitNet ternary packing implementation

| *https://en.algorithmica.org/hpc/cpu-cache/alignment/[Algorithmica: Alignment]*
| Cache alignment optimization
|===

'''

[[see-also]]
== See Also

* link:ternary-mathematical-foundations.adoc[Ternary Mathematical Foundations] ‚Äî Why ternary is optimal (Paper 1)
* link:ternary-arithmetic-algorithms.adoc[Ternary Arithmetic Algorithms] ‚Äî Addition, subtraction, multiplication, division (Paper 2)
* link:ternary-logic-algorithms.adoc[Ternary Logic Algorithms] ‚Äî Three-valued logic operations (Paper 3)
* link:ternary-conversion-algorithms.adoc[Ternary Conversion Algorithms] ‚Äî Base conversion procedures (Paper 4)

'''

[.text-center]
--
*<<_top,‚Üë Back to Top>>*

'''

*Key:* {key} ‚Ä¢ *Type:* {type} ‚Ä¢ *Version:* {version}

*Status:* {status} ‚Ä¢ *Updated:* {updated}

'''

_"Is not this laid up in store with me?"_ ‚Äî *Deuteronomy 32:34 KJV*

_"Isn't this laid up in store with me, sealed up among my treasures?"_ ‚Äî *Deuteronomy 32:34 WEB*

*Ternary data, laid up in store ‚Äî sealed efficiently, retrieved faithfully.*
--

////
===============================================================================
END FOOTER
===============================================================================
////
