////
#!omni document --adoc
===============================================================================
METADATA BLOCK
===============================================================================
////

// -----------------------------------------------------------------------------
// IDENTITY
// -----------------------------------------------------------------------------
:key: B-word-research-ternary-packing-algorithms
:title: Ternary Packing Algorithms: Horner's Method and State Space Proofs
:type: Research

// -----------------------------------------------------------------------------
// STATE
// -----------------------------------------------------------------------------
:status: Active
:version: a-01.00
:revdate: 2025-12-13

// -----------------------------------------------------------------------------
// TEMPORAL
// -----------------------------------------------------------------------------
:created: 2025-12-13
:updated: 2025-12-13

// -----------------------------------------------------------------------------
// ATTRIBUTION
// -----------------------------------------------------------------------------
:authors: Nova Dawn (Researcher), Seanje Lenox-Wise (Architect)
:author: Nova Dawn
:email: nova@creativeworkzstudio.com

// -----------------------------------------------------------------------------
// LOCATION
// -----------------------------------------------------------------------------
:path: /bereshit/word/research/ternary/

// -----------------------------------------------------------------------------
// DERIVATION
// -----------------------------------------------------------------------------
:derives_from: bereshit/word/seed/documentation/adoc/asciidoc-research.adoc

// -----------------------------------------------------------------------------
// CLASSIFICATION
// -----------------------------------------------------------------------------
:tags: ternary, mathematics, packing, horner, state-space, algorithms, proofs
:keywords: Horner's Method, Pack, Unpack, State Space, Trit5, Trit9, Bible Rail, Spare States

// -----------------------------------------------------------------------------
// INTENT
// -----------------------------------------------------------------------------
:purpose: Formalize the mathematical proofs for pack/unpack operations used in libtrit
:description: Research document proving the correctness of Horner's method for trit packing, state space bounds, and spare state calculation

// -----------------------------------------------------------------------------
// GROUNDING
// -----------------------------------------------------------------------------
:biblical_foundation: Proverbs 11:1 KJV ‚Äî A false balance is abomination to the LORD: but a just weight is his delight

// -----------------------------------------------------------------------------
// STRICTNESS
// -----------------------------------------------------------------------------
:strictness: G

// -----------------------------------------------------------------------------
// ASCIIDOC SETTINGS
// -----------------------------------------------------------------------------
:toc: left
:toclevels: 3
:sectnums:
:icons: font
:source-highlighter: highlight.js
:experimental:
:stem: latexmath

////
===============================================================================
END METADATA
===============================================================================
////

////
===============================================================================
HEADER BLOCK
===============================================================================
////

[[_top]]
= {title}

[.text-center]
--
*Mathematical proofs for balanced ternary packing operations*

image:https://img.shields.io/badge/Status-{status}-brightgreen?style=flat[Status]
image:https://img.shields.io/badge/Version-{version}-blue?style=flat[Version]
image:https://img.shields.io/badge/Type-{type}-purple?style=flat[Type]

_"A false balance is abomination to the LORD: but a just weight is his delight."_ ‚Äî Proverbs 11:1

'''

*<<overview,Overview>>* ‚Ä¢ *<<horner,Horner's Method>>* ‚Ä¢ *<<state-space,State Space>>* ‚Ä¢ *<<spare-states,Spare States>>* ‚Ä¢ *<<proofs,Proofs>>*

--

'''

////
===============================================================================
CONTEXT BLOCK
===============================================================================
////

[[overview]]
== Overview

This document formalizes the mathematical proofs underlying libtrit's pack/unpack operations. These proofs establish correctness guarantees for balanced ternary storage.

[IMPORTANT]
====
*These are the mathematical foundations for `pack.c`.* The implementation in libtrit follows these proofs exactly.
====

[NOTE]
====
*Scope:*

* ‚úì Horner's method for polynomial evaluation
* ‚úì State space bounds (3^n calculations)
* ‚úì Spare state derivation (Bible Rail)
* ‚úì Roundtrip correctness proofs
====

'''

<<_top,‚Üë Back to Top>>

'''

////
===============================================================================
CONTENT BLOCK
===============================================================================
////

[[horner]]
== Horner's Method

=== The Problem

Given n trits (each -1, 0, or +1), pack them into a single integer for storage.

=== Polynomial Representation

A sequence of n trits can be viewed as a polynomial in base 3:

----
value = t[0]√ó3‚Å∞ + t[1]√ó3¬π + t[2]√ó3¬≤ + ... + t[n-1]√ó3^(n-1)
----

Where each t[i] ‚àà {-1, 0, +1}.

=== Horner's Method

Instead of computing powers of 3 explicitly, Horner's method factors the polynomial:

----
value = t[0] + 3√ó(t[1] + 3√ó(t[2] + 3√ó(... + 3√ót[n-1])))
----

*Algorithm (pack):*
[source,c]
----
int pack(trit_t trits[], int n) {
    int value = 0;
    for (int i = n-1; i >= 0; i--) {
        value = value * 3 + (trits[i] + 1);  // shift +1 to map -1,0,+1 ‚Üí 0,1,2
    }
    return value;
}
----

*Algorithm (unpack):*
[source,c]
----
void unpack(int value, trit_t trits[], int n) {
    for (int i = 0; i < n; i++) {
        trits[i] = (value % 3) - 1;  // shift -1 to map 0,1,2 ‚Üí -1,0,+1
        value = value / 3;
    }
}
----

=== Why This Works

The +1 shift transforms balanced ternary (-1, 0, +1) to unsigned (0, 1, 2):

[cols="^1,^1,^1"]
|===
| Balanced | Shift | Unsigned

| -1 | +1 | 0
| 0 | +1 | 1
| +1 | +1 | 2
|===

This allows standard base-3 arithmetic on unsigned values.

'''

<<_top,‚Üë Back to Top>>

'''

[[state-space]]
== State Space

=== State Count Formula

For n trits, the total number of distinct states is:

----
states(n) = 3^n
----

[cols="^1,^2,^3,^3"]
|===
| n | 3^n | Storage | Application

| 1 | 3 | 2 bits | Single trit
| 5 | 243 | 1 byte (8 bits) | trit5_t
| 9 | 19,683 | 2 bytes (16 bits) | trit9_t
| 27 | 7,625,597,484,987 | 6 bytes (48 bits) | trit27_t
|===

=== Proof: 3^n States

*Claim:* n balanced ternary digits can represent exactly 3^n distinct values.

*Proof:*
----
Base case: n=1
  Single trit has 3 values: {-1, 0, +1}
  3^1 = 3 ‚úì

Inductive step: Assume 3^k states for k trits.
  Adding one more trit multiplies states by 3:
  (k+1 trits) = (3 choices for new trit) √ó (3^k states for k trits)
             = 3 √ó 3^k = 3^(k+1) ‚úì

By induction, n trits = 3^n states. ‚ñ°
----

=== Range Formula

For n balanced ternary digits, the representable range is:

----
range = [-(3^n - 1)/2, +(3^n - 1)/2]
----

[cols="^1,^2,^2"]
|===
| n | Min | Max

| 5 | -121 | +121
| 9 | -9,841 | +9,841
| 27 | -3,812,798,742,493 | +3,812,798,742,493
|===

'''

<<_top,‚Üë Back to Top>>

'''

[[spare-states]]
== Spare States (Bible Rail)

=== The Discovery

When storing 5 trits in 1 byte:

----
Trit states:  3^5 = 243
Byte states:  2^8 = 256
Spare:        256 - 243 = 13 states
----

These 13 spare states (243-255) are reserved for Bible Rail encoding.

=== Why 13?

----
spare(n, m) = 2^m - 3^n

For trit5 in 1 byte:
  spare(5, 8) = 256 - 243 = 13
----

=== Spare State Detection

[source,c]
----
bool trit5_is_spare(trit5_t value) {
    return value >= 243;
}
----

This function is the implementation of: `value ‚àà [243, 255]`

=== Purpose

[cols="2,4"]
|===
| Range | Use

| 0-242 | Valid packed trit values
| 243-254 | KJV‚ÜîWEB translation variants
| 255 | Reserved (escape/special)
|===

'''

<<_top,‚Üë Back to Top>>

'''

[[proofs]]
== Correctness Proofs

=== Roundtrip Correctness

*Theorem:* For any valid trit array t[0..n-1], unpack(pack(t)) = t.

*Proof:*
----
Let p = pack(t) using Horner's method.

p = Œ£ (t[i]+1) √ó 3^i  for i = 0 to n-1

Unpack extracts each digit:
  t'[i] = (p / 3^i) mod 3 - 1

Since p was constructed with exactly this encoding:
  (p / 3^i) mod 3 = t[i] + 1

Therefore:
  t'[i] = (t[i] + 1) - 1 = t[i]

For all i, t'[i] = t[i]. ‚ñ°
----

=== Uniqueness

*Theorem:* Each packed value corresponds to exactly one trit sequence.

*Proof:*
----
The packing function is a bijection from {-1,0,+1}^n to {0,1,...,3^n-1}.

Injectivity: Different trit sequences produce different sums.
  (Follows from uniqueness of base-3 representation)

Surjectivity: Every integer in [0, 3^n-1] is reachable.
  (Follows from counting: 3^n inputs, 3^n outputs)

Therefore, pack is a bijection, and unpack is its inverse. ‚ñ°
----

=== Boundary Conditions

*Theorem:* pack always produces values in [0, 3^n - 1].

*Proof:*
----
Minimum: All trits = -1
  pack([-1,-1,-1,-1,-1]) = Œ£ 0√ó3^i = 0

Maximum: All trits = +1
  pack([+1,+1,+1,+1,+1]) = Œ£ 2√ó3^i = 2√ó(3^n-1)/(3-1) = 3^n - 1

For trit5: min=0, max=242 ‚úì
----

'''

<<_top,‚Üë Back to Top>>

'''

[[quick-reference]]
== Quick Reference

*Key Formulas:*

[cols="3,4"]
|===
| Formula | Meaning

| `3^n`
| Number of states for n trits

| `(3^n - 1) / 2`
| Maximum value in balanced range

| `2^m - 3^n`
| Spare states when n trits stored in m bits

| `value * 3 + (trit + 1)`
| Pack step (Horner's method)

| `(value % 3) - 1`
| Unpack step
|===

*Implementation:* link:../../work/pkg/trit/src/pack.c[pack.c]

'''

////
===============================================================================
FOOTER BLOCK
===============================================================================
////

[[biblical-foundation]]
== Biblical Foundation

[NOTE]
====
*Just weights and measures.* The mathematical precision of these algorithms reflects the exactness God requires. A "false balance" ‚Äî imprecise encoding ‚Äî would corrupt data. The proofs guarantee "just weight" ‚Äî exact roundtrip fidelity.
====

_"A false balance is abomination to the LORD: but a just weight is his delight."_ ‚Äî *Proverbs 11:1*

*Applied:* These proofs establish that our encoding is "just" ‚Äî no data is lost, no corruption occurs. The spare states are not arbitrary but mathematically necessary, and we dedicate them to Scripture encoding. The structure of mathematics itself provides room for the Word.

'''

<<_top,‚Üë Back to Top>>

'''

[[references]]
== References

=== Related Documents

[cols="^1,3,4"]
|===
| | Document | Purpose

| üìê
| *link:ternary-mathematical-foundations.adoc[Ternary Mathematical Foundations]*
| Why base 3 is optimal (radix economy)

| üìê
| *link:ternary-storage-algorithms.adoc[Ternary Storage Algorithms]*
| Storage mapping patterns

| üîß
| *link:../../work/pkg/trit/src/pack.c[pack.c]*
| Implementation of these algorithms

| üîß
| *link:../../work/pkg/trit/libtrit-api.adoc[libtrit API]*
| API reference for pack/unpack functions
|===

=== External Resources

[cols="2,5"]
|===
| Resource | Purpose

| *https://en.wikipedia.org/wiki/Horner%27s_method[Horner's Method]*
| Algorithm for polynomial evaluation

| *https://en.wikipedia.org/wiki/Balanced_ternary[Balanced Ternary]*
| Number system background
|===

'''

[[see-also]]
== See Also

* link:ternary-mathematical-foundations.adoc[Ternary Mathematical Foundations] ‚Äî Radix economy proofs
* link:../../glossary/biblical/bible-rail.adoc[Bible Rail Glossary] ‚Äî Spare state usage
* link:../../work/pkg/trit/test/[Test Suite] ‚Äî Roundtrip verification tests

'''

[.text-center]
--
*<<_top,‚Üë Back to Top>>*

'''

*Key:* {key} ‚Ä¢ *Type:* {type} ‚Ä¢ *Version:* {version}

*Status:* {status} ‚Ä¢ *Updated:* {updated}

'''

_"{biblical_foundation}"_

*Mathematical proofs ensuring just weights in ternary encoding.*

--

////
===============================================================================
END FOOTER
===============================================================================
////
